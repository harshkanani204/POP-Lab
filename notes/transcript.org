#+STARTUP: indent
* Information.
- Youtube play list ::
https://www.youtube.com/playlist?list=PLhMQ0_-r9W5-LeXeXQtW8UcmtdJk98hfH

- Repository ::
https://bitbucket.org/piyush-kurur/popl



* DONE Functional Programming - Getting started                     :LECTURE:
- Video :: https://www.youtube.com/watch?v=slmy8JH5Llo

Language that we will use is Standard ML (SML)

ML stands for Meta Language

** SML/NJ - New Jersey

- Interpreter
- Is quick to use
- Is good for interactive sessions
- Standalone programs can be written but not recommended.

*** Installation

#+BEGIN_SRC
sudo apt intall smlnj      # the smlnj system.
sudo apt install rlwrap    # for adding history support for sml
sudo apt install sml-mode  # for emacs
#+END_SRC

** Mlton

- Full program optimising compiler
- Is slow to use (the compilation process is slow)
- Produces standalone fast executables


*** Installation

#+BEGIN_SRC
sudo apt install mlton

#+END_SRC

*** Compiling code

#+BEGIN_SRC
mlton foo.hs # produces the foo executable
./foo        # run the executable

mlton -output myprog foo.hs # generate executable in myprog
./myprog

#+END_SRC

** Tale of two SML's
 - For interactive use smlnj
   - on terminal or in emacs

 - for standalone compiling use mlton

* DONE Standard ML Programming model                                :LECTURE:
- Video :: https://www.youtube.com/watch?v=WoVXpQkhVhw
- Video :: https://www.youtube.com/watch?v=QVxqTi8iCzw&t=5s

- The mental model of what programs are and what they do

- This need not be the way in which the language is really
  implemented.

** C programming model

- C programs have a set of variables  which are memory cells
- Assignment statements update these cells
- Programs are essentially such statements
- Computation happens by running these statements in a sequence.





** SML programming model

*** Programs are variable bindings

#+BEGIN_SRC sml
val x = 10     (* binds x to the value 10 *)
val y = x + 2  (* it evalutes x + 2 and binds it to y *)
val z = x + y

(* Binding looks like

val <variable> = expression

*)

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 12 : int
: val z = 22 : int

**** Commentary

#+BEGIN_SRC  sml
val x = 10
(*
   1. 10 is itself a value so no reduction.
   2. x gets bound to 10
*)

val y = x + 2
(*
  RHS is x + 2 -----> 10 + 2 ---> 12

  y gets bound to 12

*)
val z = x + y

(*
RHS is x + y ---> 10 + y ----> 10 + 12 ---> 22

z gets bound to 22

*)

#+END_SRC

*** Computations happen when expressions are evaluated.


1. When variables are encountered during evalution, the corresponding
   value is substituted for it and the evaluation process continues.

**** Expressions (examples)

- 2
- 3 + 100
- x
- "hello"
- print "hello"

**** Values and reductions.

A subset of expressions are designated as values and are considered
in their simplest form (normal form).

Anything that is not a value needs simplification (reduction).

#+BEGIN_SRC

3 + (10 * 2) ---->  3 + 20 ---> 23 which is value

x --> We need to look up at that point what is the value bound to x

#+END_SRC




*** SML programs are just bindings.

1. A program is a list of bindings
2. Each binding defines a variable and associates it with a value
3. The value associated to a variable is obtained by
   reducing/simplifying the RHS.
4. Computations happen while these reductions are done.

** Pure values vs evaluation with side effects.

#+BEGIN_SRC sml

val x = print "hello\n"
val y = ()
#+END_SRC

#+RESULTS:
: hello
: val x = () : unit
: val y = () : unit

1. x gets bound to the value ~()~ - unit or hermit
2. When ~print "hello\n"~ is reduced, it results in "hello" being printed
   on the terminal.
3. The value obtained in this case ~()~ does not reflect this side effect.
4. The evaluation of ~print "hello\n"~ results in a side effect of printing
   the string ~"hello"~

In that sense ~print "hello"~ is /not/ a /pure value/

In general it is always preferable to use pure values and use
side-effects only when necessary.



* DONE Types                                                        :LECTURE:
- Video :: https://youtu.be/qC4RkYatlC0

** SML is a typed programming language

#+BEGIN_SRC sml
val x     = 10
val hello = "hello"
val y     = (1,"hello")
val z     = [1,2,3]
val z1    = ["hello", "world"]
(*

x : T   means x has the type T

*)
#+END_SRC

#+RESULTS:
: val x = 10 : int
: val hello = "hello" : string
: val y = (1,"hello") : int * string
: val z = [1,2,3] : int list
: val z1 = ["hello","world"] : string list

** Types rule out certain programs.


#+BEGIN_SRC  sml
val x = 2 + "hello"

#+END_SRC

#+RESULTS:
: stdIn:32.5-32.20 Error: operator and operand don't agree [overload conflict]
:   operator domain: [+ ty] * [+ ty]
:   operand:         [+ ty] * string
:   in expression:

** Types are taken seriously (strongly typed)


#+BEGIN_SRC sml

val x = 2.5
val z = 2
val y = x * 2

#+END_SRC

#+RESULTS:
: stdIn:48.5-48.14 Error: operator and operand don't agree [overload conflict]
:   operator domain: real * real
:   operand:         real * [int ty]
:   in expression:


** Strict types are great for safety

Write a program to take two numbers and compute its average.

*** In C

#+BEGIN_SRC C

# include<stdio.h>
double average( double x , double y )
{
   return 1.0/2.0 * (x + y);
}

int main ()
{
   printf("%g", average(2,3));
   return 0;
}

#+END_SRC

#+RESULTS:
: 2.5


*** In SML

#+BEGIN_SRC sml

fun average x y = 1.0/2.0 * (x + y)

#+END_SRC

#+RESULTS:
: val average = fn : real -> real -> real

* DONE Functions                                                    :LECTURE:
- Video :: https://youtu.be/IVeW5wv0wcA

** Definition of functions
#+BEGIN_SRC sml
fun identity x = x
fun increment x = x + 1
val z = identity 10
val helo = identity "hello"
val foo  = identity [1,2,3]
fun idInt (x : int)  = x

(*

The type of functions form A to B is A -> B
'a is a type variable.
*)
#+END_SRC
#+RESULTS:
: val identity = fn : 'a -> 'a
: val increment = fn : int -> int
: val z = 10 : int
: val helo = "hello" : string
: val foo = [1,2,3] : int list
: val idInt = fn : int -> int


- identity is a polymorphic function
- SML takes care of inferring the types of arguments and results.
- It infers the most general type possible

** Only single argument functions

- SML supports only single argument functions

- Recall :: If A and B are types then A -> B denotes the type
            of all functions from A to B

- Associativity of "->" :: It associates towards right
     ~A -> B -> C  === A -> (B -> C)~

*** Curried form

#+BEGIN_SRC sml

fun add x y = x + y

(* add takes a single argument x and returns a function that takes a single argument y
  and returns x + y
*)

val increment = add 1
#+END_SRC

#+RESULTS:
: val add = fn : int -> (int -> int)

*** Uncurried form

- A * B is the cartesian product of types A and B.
- elements of A * B are pairs (a,b) such that a : A and b : B
#+BEGIN_SRC sml

val z = (1, true)
val u = (1.0, 1, "hello")
fun add (x,y) = x + y

#+END_SRC

#+RESULTS:
: val z = (1,true) : int * bool
: val u = (1.0,1,"hello") : real * int * string
: val add = fn : int * int -> int


*** Conversion

#+BEGIN_SRC sml

(* curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c *)
fun curry f x y = f (x,y)
fun uncurry f (x,y) = f x y

#+END_SRC

#+RESULTS:
: val curry = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
: val uncurry = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c


* DONE Revisiting Types and Values                                  :LECTURE:

- Video :: https://youtu.be/gWz-UTGFoCI
- Video :: https://youtu.be/oqNi4F74vGk

** Why types ?

Values come with types and they govern

1. How we create values

2. How we make use of values

#+BEGIN_EXAMPLE

f : A -> B

x : A

y : B

z : C


1. f x  is okey because x is of type A and f expectes its argument to be of
   type A.  The expression f x itself is of type B


2. f y is not not okey because f was given an argument which is not its domain

#+END_EXAMPLE

- Type checking is checking whether your program violates any of the typing rules

- Type checking can catch a lot of programming bugs


|                       | Strong | Weak       |
|-----------------------+--------+------------|
| Static Type Checking  | SML    | C          |
| Dynamic Type Checking | Ruby   | JavaScript |


- Strong/Weak :: How strictly types are enforced

- Static Type checking :: The code is checked for type errors in the compilation phase
                          Nothing is done at run time

- Dynamic Type checking :: The type checking happens at run time

** Advantages of Static type checking

1. Type checking helps in finding bugs and the earlier the better

2. Since type checkings is already done the code generated can be much
   more efficient

3. SML has type inference that gives the language a feel of a
   Dynamically type checked language like ruby but gives the safety of
   a Statically type checked language.

** Basic types in SML

#+BEGIN_SRC sml
val anInt = 1
val aString = "hello"
val aChar   = #"c"
val aReal   = 2.0
val aBool   = true
val anotherBool = false
#+END_SRC

#+RESULTS:
: val anInt = 1 : int
: val aString = "hello" : string
: val aChar = #"c" : char
: val aReal = 2.0 : real
: val aBool = true : bool
: val anotherBool = false : bool

** Cartesian product of types

#+BEGIN_SRC sml
val x = (1, 2.0)
val y = ("hello", 2, true)
val z = (x,y)

val (u,v) = z  (* pattern matching
                  bind the variables u and v such that the pair (u,v) is z
                  SML sloves for u and v such that (u,v) = z in this case
                  *)

#+END_SRC

#+RESULTS:
: val x = (1,2.0) : int * real
: val y = ("hello",2,true) : string * int * bool
: val z = ((1,2.0),("hello",2,true)) : (int * real) * (string * int * bool)
: val u = (1,2.0) : int * real
: val v = ("hello",2,true) : string * int * bool

- A * B  :: The set theoretic Cartesian prodcut

A*B consists of values (a,b) where a : A and b : B

** Lists

#+BEGIN_SRC sml
val x1 = []
val x = [1,2,3]
val z = [true,false,false]
val y = 42 :: x   (* y is 42 followed by x *)
(* y is that list whose first element is 42 and the rest of the list is x *)


(* val foo = [1 ,true ]  (* This is an error all elements should be of the same type *)  *)

#+END_SRC

#+RESULTS:
: stdIn:17.11-17.21 Error: operator and operand don't agree [overload conflict]
:   operator domain: [int ty] * [int ty] list
:   operand:         [int ty] * bool list
:   in expression:

- Polymorphism :: int list, bool list etc 'a list where 'a is a type variable
- All elements of a particular list should be of the same type
- Recursively defined type/Inductive type
** What are lists

Let 'a be any type then 'a list is defined as the type consisting of

I.  [] : 'a list
II. If x : 'a and xs : 'a list then (x :: xs) : 'a list
III. The smallest collection of such values constitute the type 'a list

#+BEGIN_SRC sml
  val y = [1,2]       (* This is a syntactic sugar for the one below *)
  val x = 1 :: 2 :: []
  val u :: us = x  (* pattern matching for list *)

  (* If possible find bindings for u and us such that u :: us is the
  same as x *)
  (* val v :: vs = []  *)

  val z = [ (1,true) , (2, false) ]
  val (r,s)::ls = z

#+END_SRC

#+RESULTS:
: val y = [1,2] : int list
: val x = [1,2] : int list
: val u = 1 : int
: val us = [2] : int list
: val z = [(1,true),(2,false)] : (int * bool) list
: val r = 1 : int
: val s = true : bool
: val ls = [(2,false)] : (int * bool) list


i.  [] : int list

ii. 2 : int and [] : int list (from i) so 2 :: [] : int list (From
    rule II)

iii. 1 : int and 2:: [] : int list (from ii) and hence 1 :: 2 :: [] :
     int list (From rule II)


* DONE Pattern Matching                                             :LECTURE:

- Video :: https://youtu.be/GTPc4aPhXiQ
- Video :: https://youtu.be/RjHvrC51Hok

** What are patterns

1. Variables like ~x~ is pattern

2. Wildcard  ~_~ is a pattern (The underscore pattern)

3. If ~p1~ and ~p2~ are patterns then so is ~(p1,p2)~ and similarly for
   n-tuples

4. If ~p~ and ~ps~ are patterns then ~p :: ps~ is also a pattern

** Pattern matching.

Given an value ~v~, and a pattern ~pat~

1. Does ~pat~ match the value ~v~

2. What are the resulting variable bindings.

** Rules of pattern matching

+--------------------+-----------+---------------+-------------------------------------+
| Pattern            | Type of v | Form of the v |Bindings created                     |
+--------------------+-----------+---------------+-------------------------------------+
| Variable (say ~x~) | any type  | any value     | ~x = v~                             |
+--------------------+-----------+---------------+-------------------------------------+
| Wild card (~_~)    | any type  | any value     |No bindings created                  |
+--------------------+-----------+---------------+-------------------------------------+
| ~(p1,p2)~          | ~'a * 'b~ | ~(v1,v2)~     |match ~p1~ with ~v1~ and ~p2~ with   |
|                    |           |               | ~v2~                                |
+--------------------+-----------+---------------+-------------------------------------+
| ~p :: ps~          | ~'a list~ | ~(v :: vs)~   |matchs ~p~ with ~v~ and ~ps~ with    |
|                    |           |               | ~vs~                                |
+--------------------+-----------+---------------+-------------------------------------+
| ~[]~               | ~'a list~ | ~[]~          |no bindings created                  |
+--------------------+-----------+---------------+-------------------------------------+



1. The type checking is done (column 2) at compile time (statics)

2. Form of value (column 3) is checked at runtime.

#+BEGIN_SRC sml

val x :: xs = e  (* unless you reduce e there is no way to know
whether it is [] or is it v :: vs *)

#+END_SRC

*
** Functions via pattern matching.

#+BEGIN_SRC sml

(* fst : 'a * 'b -> 'a  *)
fun fst (x,_) = x
fun snd (_,y) = y

(* isEmpty : 'a list -> bool *)
fun isEmpty [] = true   (* 1 *)
  | isEmpty _  = false  (* 2 *)


(*  isEmpty [] ---- matches the first eqn so replace by the rhs ---> true

    isEmpty [1,2,3] == isEmpty (1 :: (2 :: 3 :: []))
             ---> does not match the eqn 1 so try eqn 2.
             y is bound to 1 and ys is bound (2 :: 3 :: [])

             ---> false

*)

(*

length : 'a list -> int

*)

fun length []         = 0
  | length (_ :: ys)  = 1 + length ys

(*
map f [x1,x2....,xn] = [f x1 , f x2 ...., f xn ]
*)

fun map f []        = []
  | map f (x :: xs) = f x :: map f xs

fun incr x = x + 1

val u = map incr [1,2, 3]

#+END_SRC

#+RESULTS:
: val fst = fn : 'a * 'b -> 'a
: val snd = fn : 'a * 'b -> 'b
: val isEmpty = fn : 'a list -> bool
: val length = fn : 'a list -> int
: val map = fn : ('a -> 'b) -> 'a list -> 'b list
: val incr = fn : int -> int
: val u = [2,3,4] : int list


* DONE Algebraic data types.                                        :LECTURE:
- Video :: https://youtu.be/TLej5OaXpgg
- Video :: https://youtu.be/oChjS-CuEqY
** Motivation

Often types are defined by enumerating all the possible values
in the type.

#+BEGIN_SRC sml

datatype mybool = True | False

val someBool = True

(*

not  : mybool -> mybool

*)
fun not True  = False
  | not False = True

#+END_SRC

#+RESULTS:
: datatype mybool = False | True
: val someBool = True : mybool
: val not = fn : mybool -> mybool


** Optional value

#+BEGIN_SRC sml

datatype 'a option = SOME of 'a | NONE

(*
headSafe  : 'a list -> 'a option
*)

fun headSafe (x :: _) = SOME x
  | headSafe []       = NONE

val x = headSafe []
#+END_SRC

#+RESULTS:
: stdIn:49.5-49.20 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: datatype 'a option = NONE | SOME of 'a
: val headSafe = fn : 'a list -> 'a option
: val x = NONE : ?.X1 option

** Recursive type.


#+BEGIN_SRC sml

datatype 'a mylist = Nil
                   | Cons of 'a * 'a mylist

fun embed Nil = []
  | embed (Cons (x,xs)) = x :: embed xs

fun revEmbed []         = Nil
  | revEmbed (x :: xs)  = Cons (x , revEmbed xs)

val my123 = revEmbed [1,2,3]
val y     = Cons (1, Cons (2, (Cons (3, Nil))))
val yl    = embed y

#+END_SRC

#+RESULTS:
: datatype 'a mylist = Cons of 'a * 'a mylist | Nil
: val embed = fn : 'a mylist -> 'a list
: val revEmbed = fn : 'a list -> 'a mylist
: val my123 = Cons (1,Cons (2,Cons #)) : int mylist
: val y = Cons (1,Cons (2,Cons #)) : int mylist
: val yl = [1,2,3] : int list


** Binary trees on 'a

1. An empty tree is a binary tree

1. If x : 'a and t1 and t2 are trees of type 'a then the tree with
   root being x and t1 and t2 being subtrees is also a tree

#+BEGIN_SRC sml

datatype 'a tree = empty
                 | node of 'a * 'a tree * 'a tree

(* inorder : 'a tree -> 'a list *)
fun inorder empty             = []
  | inorder (node (x,tL, tR)) = inorder tL @ [x] @ inorder tR

fun singleton x = node (x, empty, empty)

val t = node (2, singleton 1, singleton 3)
val y = inorder t

#+END_SRC

#+RESULTS:
: datatype 'a tree = empty | node of 'a * 'a tree * 'a tree
: val inorder = fn : 'a tree -> 'a list
: val singleton = fn : 'a -> 'a tree
: val t = node (2,node (1,empty,empty),node (3,empty,empty)) : int tree


** General form

#+BEGIN_SRC sml

datatype ('a, 'b, 'c) Name = C1
                           | C2 of sometype
                           | CN

#+END_SRC

1. Constructors are of two forms. Either ~C1~ or ~C2 of some type~

2. the types appearing on the rhs can refer to the type variables in the lhs, i.e 'a, 'b, 'c

3. The type can be recursive, i.e sometype can refer to Name itsef.


*** The consequence of a datatype definition

1. A new polymorphic type ~('a, 'b, 'c) Name~ is created

2. Constructors becomes functions.

#+BEGIN_EXAMPLE sml

C1 : ('a,'b,'c) Name
C2 : sometype -> ('a,'b, 'c) Name
C3 : ('a,'b,'c) Name

#+END_EXAMPLE

3. Constructors can be used in pattern matching involving values of
   the type Name.

   i. ~C1~ is a pattern of type ~('a, 'b, 'c) Name~
   ii. If ~p~ is a pattern of type something then ~C2 p~ is also a pattern
* DONE Structures, Signatures, Functors.                            :LECTURE:
- Video :: https://youtu.be/_AwO5d7WhPI
- Video :: https://youtu.be/bAGppGJjglQ
** Motivation

Controlling the scope of a name binding.

#+BEGIN_SRC  sml
val x = 10
type foo = int
datatype bar = biz | bhur
fun incr x = x + 1

structure A = struct
   type foo     = int
   val x    : foo = 42
   fun incr (y : foo) = y + 1
end

val z  = A.x
val z1 = x

#+END_SRC

#+RESULTS:
#+begin_example
val x = 10 : int
type foo = int
datatype bar = bhur | biz
val incr = fn : int -> int
structure A :
  sig
    type foo = int
    val x : foo
    val incr : foo -> int
  end
val z = 42 : foo
val z1 = 10 : int
#+end_example


** Explicit signatures and controlling exports


#+BEGIN_SRC sml

signature MYSIG = sig
   type foo
   val x : foo
end

structure A  : MYSIG
   = struct
       type foo = int
       val x : foo = 10
       val inner : foo = 42
     end

structure B : MYSIG
   = struct
         type foo = string
         val x   = "hello"
         val internalString = "The answer is 42"
     end
val z1 = A.x
val z2 = B.x

(*
val z2 = A.inner (* with explicit signatures inner is hidden and hence error *)

*)
#+END_SRC

#+RESULTS:
: signature MYSIG =
:   sig
:     type foo
:     val x : foo
:   end
: structure A : MYSIG
: structure B : MYSIG
: val z1 = 10 : foo
: val z2 = "hello" : B.foo

** Functors

- Main Idea :: Functors are "functions" on structures

#+BEGIN_SRC sml

datatype order = LESS | GREATER | EQUAL

signature ORD = sig
   type t
   val compare : t * t -> order
end

structure IntOrd = struct
   type t = int
   fun compare (x,y) = if x < y then LESS
                       else if x > y then GREATER
                            else EQUAL

end

functor InvertORD (O : ORD) : ORD = struct

   type t = O.t
   fun compare (x,y) = O.compare (y,x)

end

structure InvIntOrd = InvertORD ( IntOrd )

val tup = (3,3)
val z = IntOrd.compare  tup
val z1 = InvIntOrd.compare tup

#+END_SRC

#+RESULTS:
#+begin_example
datatype order = EQUAL | GREATER | LESS
signature ORD =
  sig
    type t
    val compare : t * t -> order
  end
structure IntOrd :
  sig
    type t = int
    val compare : int * int -> order
  end
functor InvertORD(O: sig
                       type t
                       val compare : t * t -> order
                     end) :
                 sig
                   type t
                   val compare : t * t -> order
                 end
structure InvIntOrd : ORD
val tup = (3,3) : int * int
val z = EQUAL : order
val z1 = EQUAL : order
#+end_example

** General remarks

1. We really need only values (types and functions) for programs

2. Structures gives modularity and abstraction for coding in large.

   - Reuse or overloading ::

        #+BEGIN_SRC sml


        functor Sort ( O : ORD ) : sig
           val sort : O.t list -> O.t list
          end
          = struct
            fun sort xs = xs
            end

        #+END_SRC

        #+RESULTS:
        : functor Sort(O: sig
        :                   type t
        :                   val compare : t * t -> order
        :                 end) :
        :             sig val sort : O.t list -> O.t list end

   - Abstract types :: Types which can only be processed in a specific way.

   - At the meta level :: This is not at the value level where the "real" programming happens.
        values, functions and types as your workers, then the structure/functors is the managers
        of these

   - Main Idea :: This is mostly for programming in large

3. The structure layer is similar to the values layer


| Value world                     | Structure layer                              |
|---------------------------------+----------------------------------------------|
| values (~val~)                  | structures (~structure~)                     |
| types (specs on values)         | signatures (specs on structures)             |
| functions maps values to values | functors (that map structures to structures) |

4. Structures give a zero cost abstraction.

   ML with structures is as efficient as ML without structures.
   In fact the mlton compiler first defunctorises (removes structures and functors).

5. SML like Structures can be added to any language (mostly)
   C with SML like structures.
* DONE Structures and functors in practice                          :LECTURE:

Video :: https://youtu.be/95UPSteFfTA
Video :: https://youtu.be/KhSN46EiiRU

** Standard Libraries.

Many data structures, utility functions, IO functions etc are
available with the standard library system of SML

1. [[https://smlfamily.github.io/Basis/manpages.html][Standard Basis Libaray]]

2. [[https://www.smlnj.org/doc/smlnj-lib/Util/smlnj-lib.html][SML of NJ library]]


*** Opening structures.

Opening structure brings the bindings inside the structure to the
current scope.

This is not really recommended as List.map is much more understandable
than just map when in particular you have say Tree.map as well.

#+BEGIN_SRC sml

val x = splitAt

val y = let open List
        in
           splitAt
        end

#+END_SRC

#+RESULTS:
: stdIn:12.5-15.12 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: val x = fn : 'a list * int -> 'a list * 'a list
: val y = fn : ?.X1 list * int -> ?.X1 list * ?.X1 list

** Case Study: Set data structure

Details: https://www.smlnj.org/doc/smlnj-lib/Util/sig-ORD_SET.html

Algorithms often need to maintain the set of objects of a given type

A set data-structure implementation gives a way to implement this with
efficient opertions like union, intersection etc.

SML of NJ library

There are multiple implementation for Int set given by

- IntBinarySet   :: using binary tree
- IntListSet     :: using lists
- IntRedBlackSet :: using red-black trees.


The ~ORD_SET~ signature gives you what all operations are defined.



*** Defining set data structure for your own type.


1. Define an structure K of signature ORD_KEY for your datatype

#+BEGIN_SRC sml

datatype order = LESS | GREATER | EQUAL

signature ORD_KEY = sig

    type ord_key

    val compare : ord_key * ord_key -> order
end

datatype Foo = ...

structure FooORD : ORD_KEY = struct
   type ord_key = Foo
   val compare (f1,f2) = ...
end

#+END_SRC

2. Use this K as parameter to one of the Set implementation functors.

   - ListSetFn
   - BinarySetFn

#+BEGIN_SRC sml

structure FooSet = RedBlackSetFn ( FooORD )

let emptyFooSet = FooSet.empty


#+END_SRC


** Map data structure

This is to store a finite map from keys to values.

- structure IntRedBlackMap

Details: https://www.smlnj.org/doc/smlnj-lib/Util/sig-ORD_MAP.html

* DONE Opacity in signatures                                        :LECTURE:

- Video :: https://youtu.be/UUsscUwqvMI

** Motivating example

#+BEGIN_EXAMPLE sml

signature ORD_KEY = sig
   type ord_key
   val compare : ord_key * ord_key -> ordering

end

signature ORD_SET = sig
  type set
  (* Some stuff here *)
end

#+END_EXAMPLE

#+BEGIN_SRC sml

functor BinarySetFn (O : ORD_KEY) :> ORD_SET = struct

  datatype set = empty
               | node of O.ord_key * set * set


  (* external functions *)
  fun union xs ys = ...

  (* some internal functions *)

  fun internal = ..

end

#+END_SRC

1. The implementation makes use of the order structure to maintain the set
   as a /binary search tree/.

2. This BST property is crucial for the correctness of the implementation. Say
   membership test is essentially a BST search.

3. Because the ~set~ type is exposed, outside the structure one can
   write functions on ~set~ (as it is a binary tree implementation)
   which does not keep track of the BST property.

4. Next time when one uses the same datatype it fails.

5. What we really want is to expose the type ~set~ but not anything
   more, i.e. we want the ~set~ type to be /abstract/

Opaque signature is for this.


- Howto :: Use ~structure A :> SIG~ instead of ~structure A : SIG~.

** Examples

#+BEGIN_SRC sml

signature SIG = sig
  type foo
  val x : foo
end

structure A : SIG = struct

   type foo = int
   val x = 4

end

structure B :> SIG = struct
   type foo = int
   val x = 42

end

val z  : int = A.x  (* recognises that A.foo which is the type of A.x is int *)
val z1 = B.x        (* B.x is of type B.foo which is different for int outside B *)

#+END_SRC

#+RESULTS:
: signature SIG =
:   sig
:     type foo
:     val x : foo
:   end
: structure A : SIG
: structure B : SIG
: val z = 4 : int
: val z1 = - : B.foo

** Translucence instead of Opaque

#+BEGIN_SRC sml

signature SIG = sig
  type foo
  type bar    = int
  val x : foo
  val y : bar

end

structure A :> SIG = struct
  type foo = int
  type bar = int
  val x = 42
  val y = 42
end

val z = A.y + 1   (* A.bar is transparent *)
val z1 = A.x + 1  (* is an error as A.foo is abstract type opaque *)
#+END_SRC

#+RESULTS:
: stdIn:128.5-128.17 Error: operator and operand don't agree [overload conflict]
:   operator domain: [+ ty] * [+ ty]
:   operand:         A.foo * [int ty]
:   in expression:


* DONE Lambda Calculus: The "core" of functional programming        :LECTURE:
- Video :: https://youtu.be/OH8mVopLJIs

** What all do we need for a minimal functional languages

- Variables :: x, y, ...

- Function applications ::  ~f e~

- Function abstraction :: ~fn x => e~ This denotes the function that maps ~x~ to ~e~


This is all that we need to get the full power of a programming
language.

There is a way to encode all possible computations by just these.

This was the observation of Church and is know as the Church Hypothesis.

Church used the notation ~λ x . e~ instead of ~fn x => e~.

#+BEGIN_SRC sml

val incr = fn x => x + 1

#+END_SRC
#+RESULTS:
: val incr = fn : int -> int

** Syntax

#+BEGIN_EXAMPLE

<expr> := <variable>
        |  <expr₁> <expr₂>          (function application )
        |  fn <variable> => <expr>  (function abstraction )
        | λ <variable> . <expr>     (Church's notation for abstraction)

fn x y => e   is a short hand for fn x => fn y => e

We will use paranthesis to disambiguate.
#+END_EXAMPLE


** Semantics

The computation is captured by the notion of β-reduction.

#+BEGIN_EXAMPLE

(fn x => e) M  ===>  e [ x := M].

(fn x => fn y => x) (fn t => t) =========>
   (fn y => x) [x := M] =======> fn y => (fn t => t)

#+END_EXAMPLE

~e [x := M]~ is the notation for substitute M for x in e.

Given a λ-calculus term, any subterm can be reduced using the
β-reduction rule. And this gives computation.


Keep reducing till a term is obtained which cannot be β-reduced.


** Complications in Substitutions.

Substitutions are complicated because of variable capture.

#+BEGIN_SRC

(fn x => fn y => x y) y ====> fn y => y y  (* wrong *)

(fn x => fn z => x z) y  ====> fn z => y z (* correct *)

#+END_SRC


* DONE Lambda Calculus: Revisiting substituions                     :LECTURE:

Video :: https://youtu.be/EwRr8JBhLbA

Systematic study and formalisation of the notion of substitution and
fix problems with β-reduction.

** Free and bound variables.

In an λ-calculus term any variable x that occurs in the /shadow/ of a
~fn x => ~ is a /bound variable/ otherwise it is /free/.

#+BEGIN_EXAMPLE

F (y) ≡ fn x => x y  ( x is bound but y is free )

I(y) ≡ ₀∫¹ x y dx   ( x is bound and y is free )

ψ (z) ≡ ∀ x ∃ y ϕ(x,y,z) ( x and y are bound where as z is free).

fun foo x = print x  (here x is bound but print is free).
#+END_EXAMPLE

- The "value" associated with the term depends on the free variables
  but not on the bound variables.

- The bound variables may be replaced by "fresh" variables.



#+BEGIN_EXAMPLE

F (y) ≡ fn x => x y = fn t => t y ( x is bound but y is free )

I(y) ≡ ₀∫¹ x y dx  = ₀∫¹ t y dt  ( x is bound and y is free )

ψ (z) ≡ ∀ x ∃ y ϕ(x,y,z) = ∀ t ∃ u ϕ(t,u,z) ( x and y are bound where as z is free).

fun foo l = print l  (here x is bound but print is free).
#+END_EXAMPLE

** Formal definition.

- FV(e) :: free variables of the λ-calculus expression e is a subset of variables
           defined by induction as follows.

  1. FV(x) = { x }

  2. FV(e₁ e₂) = FV(e₁) ∪ FV(e₂)

  3. FV(λ x . e) = FV(e) ∖ {x }


- Where do bound variables get bound.

#+BEGIN_EXAMPLE
fn x => (fn x => x) ≡  fn x₀ => (fn x₁ => x₁)
#+END_EXAMPLE

The innermost binding is the strongest.

*** Substitution e [x := M]

e [x := M] stands for the expression e' obtained by substituting M for all
free occurance of x in e.

- Variable Substitution rule ::

  1. x [ x := M ]  ≡ M

  2. y [ x := M ]  ≡ y  (if y ≠ x)

- Substitution in application :: (e₁ e₂) [ x := M ] ≡ (e₁ [x := M]) (e₂ [x := M])

- Substitution in abstraction ::

     1. (λ x . e) [ x := M] = (λ x . e) (only substitute for free occurance)

     2. (λ y . e) [ x := M] = (λ y . e [x := M]) (if y ≠ x)

** β-reduction

#+BEGIN_EXAMPLE

(λ x . e) M ===> e [ x := M]

#+END_EXAMPLE


- Side condition :: No free variables of M should be bound in e

- α-reduction :: change the bound variables of e to fresh variables.

    (λ z . M) ===>  (λ u . M [ z := u ]) where u is fresh.



* DONE Typed lambda calculi                                         :LECTURE:

- Video :: https://youtu.be/O7-W3lVFAyI

I have used calculi (the plural) instead of the calculus.

** Introduction

- What are the Types :: This can be just simple types or
  much more complicated say involving polymorphism etc.

- Typing Judgements :: Let ~e~ be a term in the calculus and let ~τ~
     be a type. Judgements are assertions of the kind ~e~ has type
     ~τ~ Judgements are written in the notation ~e : τ~

- Typing rules :: These are a set of rules which tell you what judgements
                  your are allowed to make. These often come with pre-conditions
                  which are themselves judgements.

- Type checking problem :: Given an expression ~e~ and a type ~τ~,
     decide whether the judgement ~e : τ~ is a /valid judgement/ (as
     described by the typing rules) or not.

- Type inference problem :: Given an expression ~e~ compute a type ~τ~
  (if possible) such that ~e : τ~ is valid. If ~e~ is ill-typed, i.e if
  there is no τ such that ~e : τ~ is valid then report error.


** Typing judgement generalisation.

*** When is the judgement ~x : τ~ valid ?

We cannot decide on this without knowing ~x~.
We need to know the type of ~x~.

*** For terms.

The judgement ~e : τ~ can only be asserted under type assumptions on
free variables of ~e~


*** Generalisation.


- Type assumption :: A type assumption is a judgement of the kind ~x : τ~ for
     some variable ~x~.

- Judgement would be :: ~Γ ⊢ e : τ~ where Γ = { x₁ : τ₁, ... , xₙ : τₙ }
  is a set of type assumptions.

- Type checking/inference :: can be done only for the case when ~Γ ⊃ FV(e)~

- Typing rules will talk about this generalised judgements.


** Typing rules and proofs.


#+BEGIN_EXAMPLE

J₁
J₂
J₃
.
.
.
Jₙ
====================
J

#+END_EXAMPLE

In the rule above ~Jᵢ~, i.e. the judgements above the line, are called
the /pre-conditions/ and the judgement ~J~ is called the /conclusion/
of the rule.


#+BEGIN_EXAMPLE

Γ ⊢ f : τ₁ → τ₂

Γ ⊢ e : τ₁

============

Γ ⊢ f e : τ₂

#+END_EXAMPLE

*** A proof

Fix a set of rules R₁,... Rₖ.


A proof is a sequence of judgements that satisfy

- An empty sequence is a proof

- If γ = J₁,...,Jₙ is a proof and if Rᵢ is a rule which all its
  pre-conditions in γ, then the sequence J₁,...,Jₙ, J is also a proof
  where J is the conclusion of Rᵢ. (Applying the  rule Rᵢ).

A proof of a judgement J is just a valid proof whose last judgement is J.

* DONE Simply Typed lambda calculus                                 :LECTURE:
- Video :: https://youtu.be/V5voaE9BiDk
** Types of the language.

- Basic types :: Fix a set of basic types B = { nat, bool}.

- Types are defined inductively as follows.


#+BEGIN_EXAMPLE
τ = t  where t ∈ B
  | τ₁ -> τ₂ where τ₁ and τ₂ are types.

#+END_EXAMPLE

** The calculus with nat and bool


#+BEGIN_EXAMPLE
<expr> = n                         for all n ∈ ℕ
       | true                      boolean constant
       | false                     boolean constant
       | and                       builtin function
       | or                        builtin function
       | not                       builtin function
       | plus                      builtin function
       | <variable>                  Variable
       | <expr>₁ <expr>₂             application
       | λ <variable> : τ . <expr>   abstraction

#+END_EXAMPLE

** Typing rules.

For every construct in the language, there should be a typing rule.

*** Builtins

#+BEGIN_EXAMPLE

===============  for all n ∈ ℕ
⊢ n : nat

#+END_EXAMPLE


#+BEGIN_EXAMPLE

===============
⊢ true : bool

#+END_EXAMPLE

... (the rest is exercise)

#+BEGIN_EXAMPLE

===========================
⊢ plus : nat -> nat -> nat


#+END_EXAMPLE

#+BEGIN_EXAMPLE

====================
⊢ and : bool -> bool -> bool

#+END_EXAMPLE

*** Variables

To determine the type of x, a variable, we need to assume its type.

#+BEGIN_EXAMPLE

===================
 {x : τ}  ⊢ x : τ

#+END_EXAMPLE

*** Application

#+BEGIN_EXAMPLE

Γ ⊢ e₁ : τ₁ → τ₂
Γ ⊢ e₂ : τ₁
====================
Γ ⊢ e₁ e₂ : τ₂

#+END_EXAMPLE

1. Make sure that ~e₁ : τ₁ -> τ₂~

2. Make sure that ~e₂ : τ₁~

*** Abstraction

#+BEGIN_EXAMPLE

Γ ∪ { x : τ₁ } ⊢ e : τ₂
========================================
Γ              ⊢ (λ x : τ₁ . e)  : τ₁ → τ₂

#+END_EXAMPLE

λ x : τ₁ . e  is that function that takes x : τ₁ and gives out e : τ₂
*** Structural rules.
**** Weakening

#+BEGIN_EXAMPLE

Γ               ⊢ e : τ
====================
Γ ∪ { x : τ₁ }  ⊢ e : τ
#+END_EXAMPLE

**** Contraction

#+BEGIN_EXAMPLE

Γ ∪ { x : τ₁ } ∪  { x : τ₁ }  ⊢ e : τ
===================================
Γ ∪ { x : τ₁ }  ⊢ e : τ

#+END_EXAMPLE

** Some Proofs.

*** plus 1 : nat -> nat

| # | Judgement                  | Rule                  |
|---+----------------------------+-----------------------|
| 1 | ⊢ plus : nat -> nat -> nat | builtin for plus      |
| 2 | ⊢ 1    : nat               | builtin for 1 ∈ ℕ     |
| 3 | ⊢ plus 1 : nat -> nat      | application using 1,2 |


*** (λ x . x ): nat -> nat

| # | Judgement                      | Rule                  |
|---+--------------------------------+-----------------------|
| 1 | { x : nat } ⊢ x : nat          | Var                   |
| 2 | ⊢ λ (x : nat) . x : nat -> nat | abstraction using 1   |


*** (λ x . λ y . x ) : nat -> bool -> nat

| # | Judgement                            | Rule                |
|---+--------------------------------------+---------------------|
| 1 | { x : nat } ⊢ x : nat                | Var                 |
| 2 | { x : nat , y : bool } ⊢ x : nat     | Weakening using 1   |
| 3 | { x : nat } ⊢ λ y . x : bool -> nat  | abstraction using 2 |
| 4 | ⊢ λ x . λ y . x : nat -> bool -> nat | abstraction using 3 |

* DONE Hindley-Milner type system                                   :LECTURE:

- Video :: https://youtu.be/Uc2m_ZxSpG8

Supports polymorphic types and is the basis for the type system
of languages like Standard ML or Haskell.


** Types

#+BEGIN_SRC sml
val map : ('a -> 'b) -> 'a list -> 'b list
#+END_SRC

~map : ∀ α ∀ β . (α -> β) -> α list -> β list~

It is assumed that there is an /outer layer/ of forall quantification.

- Base types :: A set like B = {nat, bool }
- Type variables :: A set V = {α, α₁,...αₙ,.., β, β₁...}

*** Monomorphic types (monotype)
#+BEGIN_EXAMPLE
τ := t        t ∈ B  (base types)
  |  τ₁ → τ₂
  |  α        α ∈ V  (type variables)

#+END_EXAMPLE

*** Type schemes (polymorphism).

In essence a type scheme σ is a ∀-quantified monotype.

σ = ∀ α₁...∀ αₙ τ.

#+BEGIN_EXAMPLE
σ = τ
  | ∀ α . σ₁

#+END_EXAMPLE


** Typing rules.

All these rules carry over to the Hindley-Milner setting where types
τ are monotypes.

*** Builtins

#+BEGIN_EXAMPLE

===============  for all n ∈ ℕ
⊢ n : nat

#+END_EXAMPLE


#+BEGIN_EXAMPLE

===============
⊢ true : bool

#+END_EXAMPLE

... (the rest is exercise)

#+BEGIN_EXAMPLE

===========================
⊢ plus : nat -> nat -> nat


#+END_EXAMPLE

#+BEGIN_EXAMPLE

====================
⊢ and : bool -> bool -> bool

#+END_EXAMPLE

*** Variables

To determine the type of x, a variable, we need to assume its type.

#+BEGIN_EXAMPLE

===================
 {x : τ}  ⊢ x : τ

#+END_EXAMPLE

*** Application

#+BEGIN_EXAMPLE

Γ ⊢ e₁ : τ₁ → τ₂
Γ ⊢ e₂ : τ₁
====================
Γ ⊢ e₁ e₂ : τ₂

#+END_EXAMPLE

1. Make sure that ~e₁ : τ₁ -> τ₂~

2. Make sure that ~e₂ : τ₁~

*** Abstraction

#+BEGIN_EXAMPLE

Γ ∪ { x : τ₁ } ⊢ e : τ₂
========================================
Γ              ⊢ (λ x : τ₁ . e)  : τ₁ → τ₂

#+END_EXAMPLE

λ x : τ₁ . e  is that function that takes x : τ₁ and gives out e : τ₂
*** Structural rules.
**** Weakening

#+BEGIN_EXAMPLE

Γ               ⊢ e : τ
====================
Γ ∪ { x : τ₁ }  ⊢ e : τ
#+END_EXAMPLE

**** Contraction

#+BEGIN_EXAMPLE

Γ ∪ { x : τ₁ } ∪  { x : τ₁ }  ⊢ e : τ
===================================
Γ ∪ { x : τ₁ }  ⊢ e : τ

#+END_EXAMPLE



** Typing rules for type schemes

*** Generalisation (GEN)

#+BEGIN_EXAMPLE

Γ ⊢ e : σ

α should not be free in Γ
==================
Γ ⊢ e : ∀ α . σ

#+END_EXAMPLE

Γ = {x₁ : σ₁, ...., xₙ : σₙ }

Then α should not be free in any of the type scheme σᵢ

**** Intuition

|   # | Judgement                               | Rule                |
|-----+-----------------------------------------+---------------------|
|   1 | { x : α } ⊢ x : α                       | Var                 |
|   2 | { x : α , y : β } ⊢ x : α               | Weakening using 1   |
|   3 | { x : α } ⊢ λ y . x : β -> α            | abstraction using 2 |
| 3.5 | { x : α } ⊢ λ y . x : ∀ β .  β -> α     | Gen using 3         |



|   4 | ⊢ λ x . λ y . x : α -> β -> α           | abstraction using 3 |
|   5 | ⊢ λ x . λ y . x : ∀ α ∀ β . α -> β -> α | Gen rule twice      |


1. e : ∀ α ∀ β α -> β -> α should really be seen as a family of judgements
   e : α -> β -> α for whatever α and β you want.

2. e₁ : ∀ α ∀ β . α -> β -> α  vs  e₂ : ∀ β . α -> β -> α

In the lattter case i.e for e₂ : ∀ β . α -> β -> α, while β can be freely
set to any type α cannot be.


 ~map : ∀ α ∀ β ∀ γ (α -> β -> γ) -> α list -> (β -> γ) list~
*** Specialisation (SPEC)


#+BEGIN_EXAMPLE

Γ ⊢ e : σ

σ' is a specialisation of σ  (which we denote by σ' ≤ σ)
==================
Γ ⊢ e : σ'

#+END_EXAMPLE

**** When is σ' ≤ σ

Consider ~map : ∀ α ∀ β . (α → β) → α list → β list~

σ = ∀ α₁...∀ αₙ τ

***** When σ' is a mono-type

map : (nat -> bool) -> nat list -> bool list


τ [α₁ := τ₁] .... [αₙ := τₙ] ≤ σ


***** The general cases.

~map : ∀ γ₁ γ₂ γ₃ . (γ₁ → (γ₂ → γ₃)) → γ₁ list → (γ₂ → γ₃) list~


∀ β₁ ... βₘ . τ [α₁ := τ₁] .... [αₙ := τₙ] ≤ σ

Provided βᵢ's are not free in σ


map : ∀ γ₁ ... ∀ γ₃ . (γ₁ → (γ₂ → γ₃)) → γ₁ list → (γ₂ → γ₃) list~
* TODO Type inference                                               :LECTURE:


Fix an enriched λ-calculus (this serves as our programming language).

#+BEGIN_EXAMPLE
<expr> = n                         for all n ∈ ℕ
       | true                      boolean constant
       | false                     boolean constant
       | and                       builtin function
       | or                        builtin function
       | not                       builtin function
       | plus                      builtin function
       | <variable>                  Variable
       | <expr>₁ <expr>₂             application
       | λ <variable> . <expr>   abstraction

#+END_EXAMPLE

- Input :: An expression ~e~ in the above calculus.
- Output :: A type scheme ~σ~ such that ~ ⊢ e : σ~ is a valid
            judgement using the type inference rules that we saw.
            Or if not possible flag an error.
