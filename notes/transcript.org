#+STARTUP: indent
* DONE Getting started                                            :CLASSROOM:

** Basic Information

- Instructor :: Piyush <ppk@.>
- TAs

  1. Chilankamol Sunny
  2. Haritha Madhav C
  3. Lijo M Jose

- Bitbucket Repository :: https://bitbucket.org/piyush-kurur/popl

Hosting site for git repositories

- Moodle website :: https://lms.iitpkd.ac.in
- Youtube channel :: https://www.youtube.com/channel/UCfCBIg1UZAYs5rjCR9GiBow
- Google meet link :: Link already sent to you

** Format of the lectures

/Flipped classroom/ model of lectures

- There will be weekly videos that I will post at the Youtube channel
- Interactive session weekly once (Monday 11:00-12:00 hrs/9:30-10:30)
- Lab Interactive session (PoPL Lab) (Thursdays 14:00-15:30 hrs)
- TAs will have a surprise interaction with you to check you are not asleep

** Grading

- Try have a lot of Short quizes (Monday 9:00-9:30 in the Even week). Over
  moodle (best n-2 in n). best n-1 in n (60-80%)

- End sem

** TODO At Home (Homework 0)

1. All of you have a laptop/desktop with internet

2. Should have a working GNU/Linux partition (Debian/Ubuntu)

3. Basics of computing

4. Start using a good editor (Emacs)

5. Should know how to install some software.

#+BEGIN_SRC bash

sudo apt install git   # debian/ubuntu
sudo apt install mlton

#+END_SRC

** Things to learn in the process of doing this course

1. git
2. make files etc dev tools on linux

** What this course is about

- Basic principles by which programming languages are designed

  - Functional Programming (SML - Standard Meta Language)
  - Rust (Imperative programming language)
  - Logical programming (Prolog)
  - Type systems, Concurrency, Modularity - Principles behind programming
languages.

- Compilers in the next semester

- Lab component

  - Using the theory and putting it into practice.
  - Side benefits (git, general programming practices)
  - Compilers course next semester some of these things will put into practice


* DONE Basics of Standard ML                                      :CLASSROOM:
SCHEDULED: <2020-08-10 Mon>

** The programming model for Languages

- It is a mental model of what the program /is/ and what it /does/.

- It might not be the actual implementation model. Is typically the
  machine model.

- The distinction between the programming model and the implementation
  model is important because the programming model is often
  simpler/convenient for Humans.

- Moral :: Programming Languages are both for Humans to understand and
  for machines to perform.

*** C Language

- Variables that are memory cells
- assignments that update memory cells
- There is a control flow which determines in what order the instructions are executed

** Programming model for SML

*** Variable Bindings

#+BEGIN_SRC sml

val x = 10     (* Binds the variable x to the value 10 *)
val y = 5 + 2  (* RHS = 5 + 2 (expression) ----> 7 (value)
                  Bind the value 7 to y
               *)
val z = x + y  (* RHS is not value.
                 x + y ----> 10 + y (substitution of x)
                       ----> 10 + 7 (substitution of y)
                       ----> 17
                 Binds z to 17
                 *)
val amitabbachan = "Big B"
val z1 = amitabbachan

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 7 : int
: val z = 17 : int
: val amitabbachan = "Big B" : string
: val z1 = "Big B" : string

*** Expressions

- Values are certain expressions which are no more reducible.
- Values are expressions that are in reduced form (simplified form)
- Values are defined based on the context


**** Examples

- 2     (value)
- 3 + 5 (not value) where as 8 is value
- x     (not value) but we need to figure it out from the binds applicable at the point

- "hello"



*** Computations/effects happen while expressions are evaluated.
** Hello world

#+BEGIN_SRC sml

val x = print "Hello World\n"

#+END_SRC

#+RESULTS:
: Hello World
: val x = () : unit

** Side effects and pure expressions.

#+BEGIN_SRC sml

val x = print "hello\n"  (* Prints the string "hello" as a side effect *)
val y = ()
val z = x (* No side effect as () is a value and
             hence need no reduction *)

val z = () (* This is equivalent to the above binding *)

(*

 print "hello\n" (expression)
   ----> ()

In the process there is a side effect of
printing the "hello\n"

*)

#+END_SRC

#+RESULTS:
: hello
: val x = () : unit

Certain expressions on reduction has side effects
e.g = ~print "hello\n"~ . Evaluating it has an effect on
the outside world.


Those Expressions whose evaluation  do not have side effect is
called a /pure expression/

1. ~print "hello"~ is an expression that is /not/ a value
2. It reduces to the value ~()~
3. The reduction has the side effect of printing "hello"
4. However, the resulting value ~()~ has no side effect.

*** SML is /not/ a pure functional programming language

Because there are expressions (e.g ~print "hello"~) whose reductions
have side effect.




** Unit

1. Type called ~unit~
2. It has only one value ~()~ (call this unit, void)

#+BEGIN_SRC sml
fun identity x  = x
fun hello ()   = print "hello\n"
fun hello1 x   = print "hello1\n"
val z          = hello () (* --> (1) *)
val u = identity 10
val v = identity "hello"
val u1 = hello1 42        (* --> (2) *)
val u2 = hello1 "hello"   (* --> (3) *)
val _  = hello ()
val _  = print "This is just printing without binding\n"

#+END_SRC

#+RESULTS:
#+begin_example
hello
hello1
hello1
hello
This is just printing without binding
val identity = fn : 'a -> 'a
val hello = fn : unit -> unit
val hello1 = fn : 'a -> unit
val z = () : unit
val u = 10 : int
val v = "hello" : string
val u1 = () : unit
val u2 = () : unit
#+end_example

* DONE Types and Functions                                        :CLASSROOM:
SCHEDULED: <2020-08-17 Mon>

** Standard ML has types

It is strongly enforced.


|                       | Weak types | strong types |
|-----------------------+------------+--------------|
| Static type checking  | C, C++     | SML, Java    |
| Dynamic type checking | JavaScript | Ruby, scheme |


*** Static type checking

- Advantages ::

1. Errors are caught before deployment.
2. More efficient code is expected out of static type checking

- Disadvantages ::

1. Very verbose type declarations.
2. Not easy to prototype

These complaints are because of languages like Java.

SML has this nice property that it can infer the types.

#+BEGIN_SRC sml

fun add x y = x + y

#+END_SRC

#+RESULTS:
: val add = fn : int -> int -> int

** Strong types are good

Write a function to compute the average of two real numbers.

#+BEGIN_SRC C
# include <stdio.h>
double av( double x , double y)
{
   return 1/2 * (x + y);
}

int main ()
{
   printf("the result is %g\n", av(2,3));
}


#+END_SRC

#+RESULTS:
: the result is 0

The bug is due to the automatic conversion from
integers to double.

#+BEGIN_SRC sml

fun av x y = 1.0/2.0 * (x + y)


#+END_SRC

#+RESULTS:
: val av = fn : real -> real -> real



** What are types

- Basic types :: ~int~, ~bool~, ~char~, ~string~

#+BEGIN_SRC sml
val anInt = 10
val aBool = true
val anotherBool = false
val aChar = #"c"
val aString = "hello\n"

#+END_SRC

- Compound types :: product types, lists etc

#+BEGIN_SRC sml
val y = (1, "hello")
val y1 = (1,true, "hello")
val x  = #1 y
val h =  #2 y
val z = [1,2,3]
val z1 = [ "hello", "world"]
val u = 2 :: z
val u1 = []
val u2 = "foo" :: z1
fun bar x (y : real) = x + y
fun bar1 x y = (x+1,y)

(*
 A * B  is the type of all tuples (a,b) where a : A and b : B.

'a , 'b , 'c  --> type variables

A -> B denotes the type of functions from A to B

Functions whose range is B and domain is A

*)
#+END_SRC

#+RESULTS:
#+begin_example
val y = (1,"hello") : int * string
val y1 = (1,true,"hello") : int * bool * string
val x = 1 : int
val h = "hello" : string
val z = [1,2,3] : int list
val z1 = ["hello","world"] : string list
val u = [2,1,2,3] : int list
val u1 = [] : 'a list
val u2 = ["foo","hello","world"] : string list
val bar = fn : real -> real -> real
val bar1 = fn : int -> 'a -> int * 'a
#+end_example



- Polymorphism :: SML figures out the most general possible type.
This kind of polymorphism is called parametric polymorphism


** Function evaluation

*** Variable bindings
*** Reductions/simplifications

#+BEGIN_SRC sml

fun increment x = x + 1
(* the variable increment is bound to that function which on input x gives x + 1 *)
val x = 10
val z = increment (2 + x)

fun foo (x,y) = x + y

fun bar () () = ()

val u = bar (print "hello\n")


(*
    f            e
    increment (2 + x) ---> increment (2 + x)
                     ---> increment (2 + 10)
                     ---> increment 12 ----> bind x to 12 and evalute (x + 1 )
                     ---> 12 + 1
                     ---> 13
                       match it with the lhs (identity x) which binds x to 12
    (1) reduce f
    (2) reduce e
    (3)

Eger evaluation: Arugments are reduced before functions are applied.
lazy evaluation: Arugments are evaluated only when needed.

*)

#+END_SRC

#+RESULTS:
: hello
: val increment = fn : int -> int
: val x = 10 : int
: val z = 13 : int
: val foo = fn : int * int -> int
: val bar = fn : unit -> unit -> unit
: val u = fn : unit -> unit

1. First the RHS is reduced to a value and then
   bound to x

2. During evaluation if a variable is found then
   its corresponding bound value is substituted

* DONE Algebraic data types and Pattern Matching                  :CLASSROOM:
SCHEDULED: <2020-08-24 Mon>

** More types

1. Types i.e basic types like ~int~, ~real~, ~string~
2. Cartesian produce ~int * real~
3. Function types ~int -> string~
4. Polymorphism ~'a -> 'b -> 'a~
5. Type aliasing

#+BEGIN_SRC sml

type complex = real * real
val x : complex = (2.0, 1.0)

fun realpart (a:real, b:real) = a
val z = realpart x
(*
 complex is just a new name for real * real.
As types they are the same.

*)
#+END_SRC

#+RESULTS:
: type complex = real * real
: val x = (2.0,1.0) : complex
: val realpart = fn : real * real -> real
: val z = 2.0 : real

** Algebraic type.

#+BEGIN_SRC sml

datatype Day = Sun
             | Mon
             | Tue
             | Wed
             | Thu
             | Fri
             | Sat

(* If SML did not have booleans *)
datatype Bool = True
              | False

(* how to define a value of type Day *)
val x = Sun

(* how to write functions *)

(*

Write a function isHoliday : Day -> bool

1. d : Day
2. ... : bool

*)
fun isHoliday Sun = true
  | isHoliday Sat = true
  | isHoliday _   = false


(*


isHoliday Mon  ---->
  Try in this order

  1. match isHoliday Sun with isHoliday Mon ---> true
  2. match isHoliday Sat with isHoliday Mon ---> true
  3. match isHolida  _   with isHoliday Mon ---> false


*)
(*

This is not like enum of C or C++ because
there is not automatic conversion from enum
to int and vice-versa

*)

#+END_SRC

#+RESULTS:
: stdIn:107.5-107.25 Warning: match nonexhaustive
:           Sun => ...
:
: datatype Day = Fri | Mon | Sat | Sun | Thu | Tue | Wed
: datatype Bool = False | True
: val x = Sun : Day
: val isHoliday = fn : Day -> bool

#+BEGIN_SRC sml

val x = SOME 10
val y = NONE

(*

head is a function that takes a list and
produces the first element of the list.

head : 'a list -> 'a

head is not defined on empty list
THis will be a runtime bug because

head e

headSafe : 'a list -> 'a option


datatype 'a option = SOME of 'a
                   | NONE


print : string -> ()

*)

datatype 'a Option = Some of 'a
                   | None

fun head (x :: _) = x

fun headSafe (x :: _) = SOME x
  | headSafe _        = NONE


val foo = head [1,2,3]
val bar = headSafe []
val _   = print (head ["foo" , "bar" ])
val _   = print (head [])

val _   = print (headSafe ["foo", "bar"])
#+END_SRC

#+RESULTS:
: stdIn:233.5-233.22 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: stdIn:237.5-237.42 Error: operator and operand don't agree [tycon mismatch]
:   operator domain: string
:   operand:         string option
:   in expression:

#+BEGIN_SRC C

int main ()
{
  FILE *fp;
  if ( fp = fopen("hello"))  == NULL)
  {
     /*
      handle the fact that there is no hello file */
  }
  ... stuff with fp

}

#+END_SRC
* Information.
- Youtube play list ::
https://www.youtube.com/playlist?list=PLhMQ0_-r9W5-LeXeXQtW8UcmtdJk98hfH

- Repository ::
https://bitbucket.org/piyush-kurur/popl



* DONE Functional Programming - Getting started                     :LECTURE:
- Video :: https://www.youtube.com/watch?v=slmy8JH5Llo

Language that we will use is Standard ML (SML)

ML stands for Meta Language

** SML/NJ - New Jersey

- Interpreter
- Is quick to use
- Is good for interactive sessions
- Standalone programs can be written but not recommended.

*** Installation

#+BEGIN_SRC
sudo apt intall smlnj      # the smlnj system.
sudo apt install rlwrap    # for adding history support for sml
sudo apt install sml-mode  # for emacs
#+END_SRC

** Mlton

- Full program optimising compiler
- Is slow to use (the compilation process is slow)
- Produces standalone fast executables


*** Installation

#+BEGIN_SRC
sudo apt install mlton

#+END_SRC

*** Compiling code

#+BEGIN_SRC
mlton foo.hs # produces the foo executable
./foo        # run the executable

mlton -output myprog foo.hs # generate executable in myprog
./myprog

#+END_SRC

** Tale of two SML's
 - For interactive use smlnj
   - on terminal or in emacs

 - for standalone compiling use mlton

* DONE Standard ML Programming model                                :LECTURE:
- Video :: https://www.youtube.com/watch?v=WoVXpQkhVhw
- Video :: https://www.youtube.com/watch?v=QVxqTi8iCzw&t=5s

- The mental model of what programs are and what they do

- This need not be the way in which the language is really
  implemented.

** C programming model

- C programs have a set of variables  which are memory cells
- Assignment statements update these cells
- Programs are essentially such statements
- Computation happens by running these statements in a sequence.





** SML programming model

*** Programs are variable bindings

#+BEGIN_SRC sml
val x = 10     (* binds x to the value 10 *)
val y = x + 2  (* it evalutes x + 2 and binds it to y *)
val z = x + y

(* Binding looks like

val <variable> = expression

*)

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 12 : int
: val z = 22 : int

**** Commentary

#+BEGIN_SRC  sml
val x = 10
(*
   1. 10 is itself a value so no reduction.
   2. x gets bound to 10
*)

val y = x + 2
(*
  RHS is x + 2 -----> 10 + 2 ---> 12

  y gets bound to 12

*)
val z = x + y

(*
RHS is x + y ---> 10 + y ----> 10 + 12 ---> 22

z gets bound to 22

*)

#+END_SRC

*** Computations happen when expressions are evaluated.


1. When variables are encountered during evalution, the corresponding
   value is substituted for it and the evaluation process continues.

**** Expressions (examples)

- 2
- 3 + 100
- x
- "hello"
- print "hello"

**** Values and reductions.

A subset of expressions are designated as values and are considered
in their simplest form (normal form).

Anything that is not a value needs simplification (reduction).

#+BEGIN_SRC

3 + (10 * 2) ---->  3 + 20 ---> 23 which is value

x --> We need to look up at that point what is the value bound to x

#+END_SRC




*** SML programs are just bindings.

1. A program is a list of bindings
2. Each binding defines a variable and associates it with a value
3. The value associated to a variable is obtained by
   reducing/simplifying the RHS.
4. Computations happen while these reductions are done.

** Pure values vs evaluation with side effects.

#+BEGIN_SRC sml

val x = print "hello\n"
val y = ()
#+END_SRC

#+RESULTS:
: hello
: val x = () : unit
: val y = () : unit

1. x gets bound to the value ~()~ - unit or hermit
2. When ~print "hello\n"~ is reduced, it results in "hello" being printed
   on the terminal.
3. The value obtained in this case ~()~ does not reflect this side effect.
4. The evaluation of ~print "hello\n"~ results in a side effect of printing
   the string ~"hello"~

In that sense ~print "hello"~ is /not/ a /pure value/

In general it is always preferable to use pure values and use
side-effects only when necessary.



* DONE Types                                                        :LECTURE:
- Video :: https://youtu.be/qC4RkYatlC0

** SML is a typed programming language

#+BEGIN_SRC sml
val x     = 10
val hello = "hello"
val y     = (1,"hello")
val z     = [1,2,3]
val z1    = ["hello", "world"]
(*

x : T   means x has the type T

*)
#+END_SRC

#+RESULTS:
: val x = 10 : int
: val hello = "hello" : string
: val y = (1,"hello") : int * string
: val z = [1,2,3] : int list
: val z1 = ["hello","world"] : string list

** Types rule out certain programs.


#+BEGIN_SRC  sml
val x = 2 + "hello"

#+END_SRC

#+RESULTS:
: stdIn:32.5-32.20 Error: operator and operand don't agree [overload conflict]
:   operator domain: [+ ty] * [+ ty]
:   operand:         [+ ty] * string
:   in expression:

** Types are taken seriously (strongly typed)


#+BEGIN_SRC sml

val x = 2.5
val z = 2
val y = x * 2

#+END_SRC

#+RESULTS:
: stdIn:48.5-48.14 Error: operator and operand don't agree [overload conflict]
:   operator domain: real * real
:   operand:         real * [int ty]
:   in expression:


** Strict types are great for safety

Write a program to take two numbers and compute its average.

*** In C

#+BEGIN_SRC C

# include<stdio.h>
double average( double x , double y )
{
   return 1.0/2.0 * (x + y);
}

int main ()
{
   printf("%g", average(2,3));
   return 0;
}

#+END_SRC

#+RESULTS:
: 2.5


*** In SML

#+BEGIN_SRC sml

fun average x y = 1.0/2.0 * (x + y)

#+END_SRC

#+RESULTS:
: val average = fn : real -> real -> real

* DONE Functions                                                    :LECTURE:
- Video :: https://youtu.be/IVeW5wv0wcA

** Definition of functions
#+BEGIN_SRC sml
fun identity x = x
fun increment x = x + 1
val z = identity 10
val helo = identity "hello"
val foo  = identity [1,2,3]
fun idInt (x : int)  = x

(*

The type of functions form A to B is A -> B
'a is a type variable.
*)
#+END_SRC
#+RESULTS:
: val identity = fn : 'a -> 'a
: val increment = fn : int -> int
: val z = 10 : int
: val helo = "hello" : string
: val foo = [1,2,3] : int list
: val idInt = fn : int -> int


- identity is a polymorphic function
- SML takes care of inferring the types of arguments and results.
- It infers the most general type possible

** Only single argument functions

- SML supports only single argument functions

- Recall :: If A and B are types then A -> B denotes the type
            of all functions from A to B

- Associativity of "->" :: It associates towards right
     ~A -> B -> C  === A -> (B -> C)~

*** Curried form

#+BEGIN_SRC sml

fun add x y = x + y

(* add takes a single argument x and returns a function that takes a single argument y
  and returns x + y
*)

val increment = add 1
#+END_SRC

#+RESULTS:
: val add = fn : int -> (int -> int)

*** Uncurried form

- A * B is the cartesian product of types A and B.
- elements of A * B are pairs (a,b) such that a : A and b : B
#+BEGIN_SRC sml

val z = (1, true)
val u = (1.0, 1, "hello")
fun add (x,y) = x + y

#+END_SRC

#+RESULTS:
: val z = (1,true) : int * bool
: val u = (1.0,1,"hello") : real * int * string
: val add = fn : int * int -> int


*** Conversion

#+BEGIN_SRC sml

(* curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c *)
fun curry f x y = f (x,y)
fun uncurry f (x,y) = f x y

#+END_SRC

#+RESULTS:
: val curry = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
: val uncurry = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c


* DONE Revisiting Types and Values                                  :LECTURE:

- Video :: https://youtu.be/gWz-UTGFoCI
- Video :: https://youtu.be/oqNi4F74vGk

** Why types ?

Values come with types and they govern

1. How we create values

2. How we make use of values

#+BEGIN_EXAMPLE

f : A -> B

x : A

y : B

z : C


1. f x  is okey because x is of type A and f expectes its argument to be of
   type A.  The expression f x itself is of type B


2. f y is not not okey because f was given an argument which is not its domain

#+END_EXAMPLE

- Type checking is checking whether your program violates any of the typing rules

- Type checking can catch a lot of programming bugs


|                       | Strong | Weak       |
|-----------------------+--------+------------|
| Static Type Checking  | SML    | C          |
| Dynamic Type Checking | Ruby   | JavaScript |


- Strong/Weak :: How strictly types are enforced

- Static Type checking :: The code is checked for type errors in the compilation phase
                          Nothing is done at run time

- Dynamic Type checking :: The type checking happens at run time

** Advantages of Static type checking

1. Type checking helps in finding bugs and the earlier the better

2. Since type checkings is already done the code generated can be much
   more efficient

3. SML has type inference that gives the language a feel of a
   Dynamically type checked language like ruby but gives the safety of
   a Statically type checked language.

** Basic types in SML

#+BEGIN_SRC sml
val anInt = 1
val aString = "hello"
val aChar   = #"c"
val aReal   = 2.0
val aBool   = true
val anotherBool = false
#+END_SRC

#+RESULTS:
: val anInt = 1 : int
: val aString = "hello" : string
: val aChar = #"c" : char
: val aReal = 2.0 : real
: val aBool = true : bool
: val anotherBool = false : bool

** Cartesian product of types

#+BEGIN_SRC sml
val x = (1, 2.0)
val y = ("hello", 2, true)
val z = (x,y)

val (u,v) = z  (* pattern matching
                  bind the variables u and v such that the pair (u,v) is z
                  SML sloves for u and v such that (u,v) = z in this case
                  *)

#+END_SRC

#+RESULTS:
: val x = (1,2.0) : int * real
: val y = ("hello",2,true) : string * int * bool
: val z = ((1,2.0),("hello",2,true)) : (int * real) * (string * int * bool)
: val u = (1,2.0) : int * real
: val v = ("hello",2,true) : string * int * bool

- A * B  :: The set theoretic Cartesian prodcut

A*B consists of values (a,b) where a : A and b : B

** Lists

#+BEGIN_SRC sml
val x1 = []
val x = [1,2,3]
val z = [true,false,false]
val y = 42 :: x   (* y is 42 followed by x *)
(* y is that list whose first element is 42 and the rest of the list is x *)


(* val foo = [1 ,true ]  (* This is an error all elements should be of the same type *)  *)

#+END_SRC

#+RESULTS:
: stdIn:17.11-17.21 Error: operator and operand don't agree [overload conflict]
:   operator domain: [int ty] * [int ty] list
:   operand:         [int ty] * bool list
:   in expression:

- Polymorphism :: int list, bool list etc 'a list where 'a is a type variable
- All elements of a particular list should be of the same type
- Recursively defined type/Inductive type
** What are lists

Let 'a be any type then 'a list is defined as the type consisting of

I.  [] : 'a list
II. If x : 'a and xs : 'a list then (x :: xs) : 'a list
III. The smallest collection of such values constitute the type 'a list

#+BEGIN_SRC sml
  val y = [1,2]       (* This is a syntactic sugar for the one below *)
  val x = 1 :: 2 :: []
  val u :: us = x  (* pattern matching for list *)

  (* If possible find bindings for u and us such that u :: us is the
  same as x *)
  (* val v :: vs = []  *)

  val z = [ (1,true) , (2, false) ]
  val (r,s)::ls = z

#+END_SRC

#+RESULTS:
: val y = [1,2] : int list
: val x = [1,2] : int list
: val u = 1 : int
: val us = [2] : int list
: val z = [(1,true),(2,false)] : (int * bool) list
: val r = 1 : int
: val s = true : bool
: val ls = [(2,false)] : (int * bool) list


i.  [] : int list

ii. 2 : int and [] : int list (from i) so 2 :: [] : int list (From
    rule II)

iii. 1 : int and 2:: [] : int list (from ii) and hence 1 :: 2 :: [] :
     int list (From rule II)


* DONE Pattern Matching                                             :LECTURE:

- Video :: https://youtu.be/GTPc4aPhXiQ
- Video :: https://youtu.be/RjHvrC51Hok

** What are patterns

1. Variables like ~x~ is pattern

2. Wildcard  ~_~ is a pattern (The underscore pattern)

3. If ~p1~ and ~p2~ are patterns then so is ~(p1,p2)~ and similarly for
   n-tuples

4. If ~p~ and ~ps~ are patterns then ~p :: ps~ is also a pattern

** Pattern matching.

Given an value ~v~, and a pattern ~pat~

1. Does ~pat~ match the value ~v~

2. What are the resulting variable bindings.

** Rules of pattern matching

+--------------------+-----------+---------------+-------------------------------------+
| Pattern            | Type of v | Form of the v |Bindings created                     |
+--------------------+-----------+---------------+-------------------------------------+
| Variable (say ~x~) | any type  | any value     |~x = v~                              |
+--------------------+-----------+---------------+-------------------------------------+
| Wild card (~_~)    | any type  | any value     |No bindings created                  |
+--------------------+-----------+---------------+-------------------------------------+
| ~(p1,p2)~          | ~'a * 'b~ | ~(v1,v2)~     |match ~p1~ with ~v1~ and ~p2~ with   |
|                    |           |               |~v2~                                 |
+--------------------+-----------+---------------+-------------------------------------+
| ~p :: ps~          | ~'a list~ | ~(v :: vs)~   |matchs ~p~ with ~v~ and ~ps~ with    |
|                    |           |               |~vs~                                 |
+--------------------+-----------+---------------+-------------------------------------+
| ~[]~               | ~'a list~ | ~[]~          |no bindings created                  |
+--------------------+-----------+---------------+-------------------------------------+



1. The type checking is done (column 2) at compile time (statics)

2. Form of value (column 3) is checked at runtime.

#+BEGIN_SRC sml

val x :: xs = e  (* unless you reduce e there is no way to know
whether it is [] or is it v :: vs *)

#+END_SRC

*
** Functions via pattern matching.

#+BEGIN_SRC sml

(* fst : 'a * 'b -> 'a  *)
fun fst (x,_) = x
fun snd (_,y) = y

(* isEmpty : 'a list -> bool *)
fun isEmpty [] = true   (* 1 *)
  | isEmpty _  = false  (* 2 *)


(*  isEmpty [] ---- matches the first eqn so replace by the rhs ---> true

    isEmpty [1,2,3] == isEmpty (1 :: (2 :: 3 :: []))
             ---> does not match the eqn 1 so try eqn 2.
             y is bound to 1 and ys is bound (2 :: 3 :: [])

             ---> false

*)

(*

length : 'a list -> int

*)

fun length []         = 0
  | length (_ :: ys)  = 1 + length ys

(*
map f [x1,x2....,xn] = [f x1 , f x2 ...., f xn ]
*)

fun map f []        = []
  | map f (x :: xs) = f x :: map f xs

fun incr x = x + 1

val u = map incr [1,2, 3]

#+END_SRC

#+RESULTS:
: val fst = fn : 'a * 'b -> 'a
: val snd = fn : 'a * 'b -> 'b
: val isEmpty = fn : 'a list -> bool
: val length = fn : 'a list -> int
: val map = fn : ('a -> 'b) -> 'a list -> 'b list
: val incr = fn : int -> int
: val u = [2,3,4] : int list


* TODO Algebraic data types.

* DONE Getting started                                                  :LAB:
SCHEDULED: <2020-08-06 Thu>

** Git

1. Installation

#+BEGIN_SRC
sudo apt install git tig gitk
#+END_SRC

2. Set your name and email id.

#+BEGIN_SRC

git config --global --edit

#+END_SRC

3. Make a local repository

#+BEGIN_SRC

mkdir code/git/ROLLNO-popl -p
cd code/git/ROLLNO-popl
git init
emacs README.md
git add README.md # Asks git to keep track of changes in this file from now own
git commit -m 'added readme' # This creates a commit with message "added readme"
# or one can avoid the -m option
git commit # will open an editor


#+END_SRC

4. Have a .gitignore file

Controls what files should be ignored by git

5. I often put a pre-commit hook

This is to avoid committing changes with trailing spaces.

#+BEGIN_SRC

# Go to the top of the repository
cd ~code/git/007-popl
mv .git/hook/pre-commit.sample .git/hook/pre-commit # Enable the pre-commit hook

#+END_SRC

6. Learn more about git and you can also use magit (git operations from emacs)


** Bitbucket stuff

1. Create account on bitbucket
2. Create a new repository in bitbucket
3. Push changes from local to bitbucket repository

#+BEGIN_SRC sh

# Create a link to the remote repository on bitbucket and call it origin.
git remote origin git@bitbucket.org:piyush-kurur/007-popl.git

# Push things here to bitbucket.
git push origin -u master

#+END_SRC


** Assignment Submission Workflow

1. Give readonly access to all TA's and me (piyush-kurur) (Using the webinterface of bitbucket)

2. Write your code in the repository (within the deadline) and commit
   it.

3. Push it to bitbucket.


** Few related things to try out

1. You can fork my popl repository on bitbucket
2. You should "Watch" my popl repository
3. You can clone repositories from (say) bitbucket
4. If the repository above is your own, then you can push stuff there.

* DONE SML Tutorial.                                                    :LAB:
* DONE Basic functions                                                  :LAB:

** Pattern matching on tuples.

#+BEGIN_SRC sml

val x     = (2, "hello") (* create a tuple *)
val (u,v) = x  (* binding by pattern matching *)
val (_,z) = x

(*
fun foo pattern = ....
*)


(*

fst : 'a * 'b -> 'a
snd : 'a * 'b -> 'b

foo (1 + 2)  ---> foo 3
             -- function call of foo --->
             let val pattern = 3 in ....

*)
#+END_SRC

#+RESULTS:
: val x = (2,"hello") : int * string
: val u = 2 : int
: val v = "hello" : string
: val z = 2 : int

** Patterns.

 1. A variable is a pattern
 2. An _ is a pattern
 3. If p1 and p2 are patterns then
    (p1, p2) is also a pattern
#+BEGIN_SRC sml

val x = 10
val _ = 10
val (p1,p2) = ...

#+END_SRC

#+RESULTS:
: stdIn:42.5-42.24 Error: pattern and expression in val dec don't agree [overload conflict]
:   pattern:    ('Z * 'Y) * 'X
:   expression:    [int ty] * [int ty]
:   in declaration:
** List patterns

'a is type

1. [] : 'a list
2. Suppose x : 'a  and  xs : 'a list then
   x :: xs is also an element of type 'a list


#+BEGIN_SRC sml

val x = [1,2,3]
val x1 = 1 :: 2 :: 3 :: []
(*  - [] is an int list
    - 3 is an int and [] is an int list so
    - 2 is an int and 3 :: [] is an int list


*)


(* isEmpty : 'a list -> bool *)
fun isEmpty []        = true
  | isEmpty (_ :: _) = false

val z = isEmpty [1,3,4]

(*  concat : 'a list -> 'a list -> 'a list

*)
fun concat (x :: xs) ys = x :: concat xs ys
  | concat []        ys = ys

val u = concat [1,2,3] [4,5 , 6]



#+END_SRC



#+RESULTS:
: val x = [1,2,3] : int list
: val x1 = [1,2,3] : int list
: val isEmpty = fn : 'a list -> bool
: val z = false : bool
: val concat = fn : 'a list -> 'a list -> 'a list
: val u = [1,2,3,4,5,6] : int list

#+BEGIN_SRC sml

fun append []       x = [x]
  | append (y :: ys) x = y :: append ys x

(* index : int -> 'a list -> 'a

*)
fun index ix xs = ...
(*

append [1,2,3] 4 => let val y = 1
                        val ys = [2,3]
                        val x  = 4
                    in y :: append ys x

  ---> 1 :: append [2,3] 4
  ---> 1 :: let val y = 2
                val ys = [3]
                val x  = 4
            in y :: append ys x

---> 1 :: (2 :: append [3] 4)
---> 1 :: 2 :: (let val y = 3
                    val ys = []
                    val x = 4
                in y :: append ys x
               )
--> 1 :: 2 :: (3 :: append [] 4)
--> 1 :: 2 :: ( 3 :: let val x = 4
                     in [x])

--> 1 :: 2 :: 3 :: [4]
= 1 :: 2 :: 3 :: 4 :: []
= [1,2,3,4]


*)

http://mlton.org/ValueRestriction

#+END_SRC
