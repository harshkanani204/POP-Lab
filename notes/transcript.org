#+STARTUP: indent
* DONE Getting started                                            :CLASSROOM:

** Basic Information

- Instructor :: Piyush <ppk@.>
- TAs

  1. Chilankamol Sunny
  2. Haritha Madhav C
  3. Lijo M Jose

- Bitbucket Repository :: https://bitbucket.org/piyush-kurur/popl

Hosting site for git repositories

- Moodle website :: https://lms.iitpkd.ac.in
- Youtube channel :: https://www.youtube.com/channel/UCfCBIg1UZAYs5rjCR9GiBow
- Google meet link :: Link already sent to you

** Format of the lectures

/Flipped classroom/ model of lectures

- There will be weekly videos that I will post at the Youtube channel
- Interactive session weekly once (Monday 11:00-12:00 hrs/9:30-10:30)
- Lab Interactive session (PoPL Lab) (Thursdays 14:00-15:30 hrs)
- TAs will have a surprise interaction with you to check you are not asleep

** Grading

- Try have a lot of Short quizes (Monday 9:00-9:30 in the Even week). Over
  moodle (best n-2 in n). best n-1 in n (60-80%)

- End sem

** TODO At Home (Homework 0)

1. All of you have a laptop/desktop with internet

2. Should have a working GNU/Linux partition (Debian/Ubuntu)

3. Basics of computing

4. Start using a good editor (Emacs)

5. Should know how to install some software.

#+BEGIN_SRC bash

sudo apt install git   # debian/ubuntu
sudo apt install mlton

#+END_SRC

** Things to learn in the process of doing this course

1. git
2. make files etc dev tools on linux

** What this course is about

- Basic principles by which programming languages are designed

  - Functional Programming (SML - Standard Meta Language)
  - Rust (Imperative programming language)
  - Logical programming (Prolog)
  - Type systems, Concurrency, Modularity - Principles behind programming
languages.

- Compilers in the next semester

- Lab component

  - Using the theory and putting it into practice.
  - Side benefits (git, general programming practices)
  - Compilers course next semester some of these things will put into practice


* DONE Basics of Standard ML                                      :CLASSROOM:
SCHEDULED: <2020-08-10 Mon>

** The programming model for Languages

- It is a mental model of what the program /is/ and what it /does/.

- It might not be the actual implementation model. Is typically the
  machine model.

- The distinction between the programming model and the implementation
  model is important because the programming model is often
  simpler/convenient for Humans.

- Moral :: Programming Languages are both for Humans to understand and
  for machines to perform.

*** C Language

- Variables that are memory cells
- assignments that update memory cells
- There is a control flow which determines in what order the instructions are executed

** Programming model for SML

*** Variable Bindings

#+BEGIN_SRC sml

val x = 10     (* Binds the variable x to the value 10 *)
val y = 5 + 2  (* RHS = 5 + 2 (expression) ----> 7 (value)
                  Bind the value 7 to y
               *)
val z = x + y  (* RHS is not value.
                 x + y ----> 10 + y (substitution of x)
                       ----> 10 + 7 (substitution of y)
                       ----> 17
                 Binds z to 17
                 *)
val amitabbachan = "Big B"
val z1 = amitabbachan

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 7 : int
: val z = 17 : int
: val amitabbachan = "Big B" : string
: val z1 = "Big B" : string

*** Expressions

- Values are certain expressions which are no more reducible.
- Values are expressions that are in reduced form (simplified form)
- Values are defined based on the context


**** Examples

- 2     (value)
- 3 + 5 (not value) where as 8 is value
- x     (not value) but we need to figure it out from the binds applicable at the point

- "hello"



*** Computations/effects happen while expressions are evaluated.
** Hello world

#+BEGIN_SRC sml

val x = print "Hello World\n"

#+END_SRC

#+RESULTS:
: Hello World
: val x = () : unit

** Side effects and pure expressions.

#+BEGIN_SRC sml

val x = print "hello\n"  (* Prints the string "hello" as a side effect *)
val y = ()
val z = x (* No side effect as () is a value and
             hence need no reduction *)

val z = () (* This is equivalent to the above binding *)

(*

 print "hello\n" (expression)
   ----> ()

In the process there is a side effect of
printing the "hello\n"

*)

#+END_SRC

#+RESULTS:
: hello
: val x = () : unit

Certain expressions on reduction has side effects
e.g = ~print "hello\n"~ . Evaluating it has an effect on
the outside world.


Those Expressions whose evaluation  do not have side effect is
called a /pure expression/

1. ~print "hello"~ is an expression that is /not/ a value
2. It reduces to the value ~()~
3. The reduction has the side effect of printing "hello"
4. However, the resulting value ~()~ has no side effect.

*** SML is /not/ a pure functional programming language

Because there are expressions (e.g ~print "hello"~) whose reductions
have side effect.




** Unit

1. Type called ~unit~
2. It has only one value ~()~ (call this unit, void)

#+BEGIN_SRC sml
fun identity x  = x
fun hello ()   = print "hello\n"
fun hello1 x   = print "hello1\n"
val z          = hello () (* --> (1) *)
val u = identity 10
val v = identity "hello"
val u1 = hello1 42        (* --> (2) *)
val u2 = hello1 "hello"   (* --> (3) *)
val _  = hello ()
val _  = print "This is just printing without binding\n"

#+END_SRC

#+RESULTS:
#+begin_example
hello
hello1
hello1
hello
This is just printing without binding
val identity = fn : 'a -> 'a
val hello = fn : unit -> unit
val hello1 = fn : 'a -> unit
val z = () : unit
val u = 10 : int
val v = "hello" : string
val u1 = () : unit
val u2 = () : unit
#+end_example

* DONE Types and Functions                                        :CLASSROOM:
SCHEDULED: <2020-08-17 Mon>

** Standard ML has types

It is strongly enforced.


|                       | Weak types | strong types |
|-----------------------+------------+--------------|
| Static type checking  | C, C++     | SML, Java    |
| Dynamic type checking | JavaScript | Ruby, scheme |


*** Static type checking

- Advantages ::

1. Errors are caught before deployment.
2. More efficient code is expected out of static type checking

- Disadvantages ::

1. Very verbose type declarations.
2. Not easy to prototype

These complaints are because of languages like Java.

SML has this nice property that it can infer the types.

#+BEGIN_SRC sml

fun add x y = x + y

#+END_SRC

#+RESULTS:
: val add = fn : int -> int -> int

** Strong types are good

Write a function to compute the average of two real numbers.

#+BEGIN_SRC C
# include <stdio.h>
double av( double x , double y)
{
   return 1/2 * (x + y);
}

int main ()
{
   printf("the result is %g\n", av(2,3));
}


#+END_SRC

#+RESULTS:
: the result is 0

The bug is due to the automatic conversion from
integers to double.

#+BEGIN_SRC sml

fun av x y = 1.0/2.0 * (x + y)


#+END_SRC

#+RESULTS:
: val av = fn : real -> real -> real



** What are types

- Basic types :: ~int~, ~bool~, ~char~, ~string~

#+BEGIN_SRC sml
val anInt = 10
val aBool = true
val anotherBool = false
val aChar = #"c"
val aString = "hello\n"

#+END_SRC

- Compound types :: product types, lists etc

#+BEGIN_SRC sml
val y = (1, "hello")
val y1 = (1,true, "hello")
val x  = #1 y
val h =  #2 y
val z = [1,2,3]
val z1 = [ "hello", "world"]
val u = 2 :: z
val u1 = []
val u2 = "foo" :: z1
fun bar x (y : real) = x + y
fun bar1 x y = (x+1,y)

(*
 A * B  is the type of all tuples (a,b) where a : A and b : B.

'a , 'b , 'c  --> type variables

A -> B denotes the type of functions from A to B

Functions whose range is B and domain is A

*)
#+END_SRC

#+RESULTS:
#+begin_example
val y = (1,"hello") : int * string
val y1 = (1,true,"hello") : int * bool * string
val x = 1 : int
val h = "hello" : string
val z = [1,2,3] : int list
val z1 = ["hello","world"] : string list
val u = [2,1,2,3] : int list
val u1 = [] : 'a list
val u2 = ["foo","hello","world"] : string list
val bar = fn : real -> real -> real
val bar1 = fn : int -> 'a -> int * 'a
#+end_example



- Polymorphism :: SML figures out the most general possible type.
This kind of polymorphism is called parametric polymorphism


** Function evaluation

*** Variable bindings
*** Reductions/simplifications

#+BEGIN_SRC sml

fun increment x = x + 1
(* the variable increment is bound to that function which on input x gives x + 1 *)
val x = 10
val z = increment (2 + x)

fun foo (x,y) = x + y

fun bar () () = ()

val u = bar (print "hello\n")


(*
    f            e
    increment (2 + x) ---> increment (2 + x)
                     ---> increment (2 + 10)
                     ---> increment 12 ----> bind x to 12 and evalute (x + 1 )
                     ---> 12 + 1
                     ---> 13
                       match it with the lhs (identity x) which binds x to 12
    (1) reduce f
    (2) reduce e
    (3)

Eger evaluation: Arugments are reduced before functions are applied.
lazy evaluation: Arugments are evaluated only when needed.

*)

#+END_SRC

#+RESULTS:
: hello
: val increment = fn : int -> int
: val x = 10 : int
: val z = 13 : int
: val foo = fn : int * int -> int
: val bar = fn : unit -> unit -> unit
: val u = fn : unit -> unit

1. First the RHS is reduced to a value and then
   bound to x

2. During evaluation if a variable is found then
   its corresponding bound value is substituted

* DONE Algebraic data types and Pattern Matching                  :CLASSROOM:
SCHEDULED: <2020-08-24 Mon>

** More types

1. Types i.e basic types like ~int~, ~real~, ~string~
2. Cartesian produce ~int * real~
3. Function types ~int -> string~
4. Polymorphism ~'a -> 'b -> 'a~
5. Type aliasing

#+BEGIN_SRC sml

type complex = real * real
val x : complex = (2.0, 1.0)

fun realpart (a:real, b:real) = a
val z = realpart x
(*
 complex is just a new name for real * real.
As types they are the same.

*)
#+END_SRC

#+RESULTS:
: type complex = real * real
: val x = (2.0,1.0) : complex
: val realpart = fn : real * real -> real
: val z = 2.0 : real

** Algebraic type.

#+BEGIN_SRC sml

datatype Day = Sun
             | Mon
             | Tue
             | Wed
             | Thu
             | Fri
             | Sat

(* If SML did not have booleans *)
datatype Bool = True
              | False

(* how to define a value of type Day *)
val x = Sun

(* how to write functions *)

(*

Write a function isHoliday : Day -> bool

1. d : Day
2. ... : bool

*)
fun isHoliday Sun = true
  | isHoliday Sat = true
  | isHoliday _   = false


(*


isHoliday Mon  ---->
  Try in this order

  1. match isHoliday Sun with isHoliday Mon ---> true
  2. match isHoliday Sat with isHoliday Mon ---> true
  3. match isHolida  _   with isHoliday Mon ---> false


*)
(*

This is not like enum of C or C++ because
there is not automatic conversion from enum
to int and vice-versa

*)

#+END_SRC

#+RESULTS:
: stdIn:107.5-107.25 Warning: match nonexhaustive
:           Sun => ...
:
: datatype Day = Fri | Mon | Sat | Sun | Thu | Tue | Wed
: datatype Bool = False | True
: val x = Sun : Day
: val isHoliday = fn : Day -> bool

#+BEGIN_SRC sml

val x = SOME 10
val y = NONE

(*

head is a function that takes a list and
produces the first element of the list.

head : 'a list -> 'a

head is not defined on empty list
THis will be a runtime bug because

head e

headSafe : 'a list -> 'a option


datatype 'a option = SOME of 'a
                   | NONE


print : string -> ()

*)

datatype 'a Option = Some of 'a
                   | None

fun head (x :: _) = x

fun headSafe (x :: _) = SOME x
  | headSafe _        = NONE


val foo = head [1,2,3]
val bar = headSafe []
val _   = print (head ["foo" , "bar" ])
val _   = print (head [])

val _   = print (headSafe ["foo", "bar"])
#+END_SRC

#+RESULTS:
: stdIn:233.5-233.22 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: stdIn:237.5-237.42 Error: operator and operand don't agree [tycon mismatch]
:   operator domain: string
:   operand:         string option
:   in expression:

#+BEGIN_SRC C

int main ()
{
  FILE *fp;
  if ( fp = fopen("hello"))  == NULL)
  {
     /*
      handle the fact that there is no hello file */
  }
  ... stuff with fp

}

#+END_SRC
* DONE Abstract syntax and datatypes                              :CLASSROOM:
SCHEDULED: <2020-09-05 Sat>

** While writing compilers

1. Captures the constructs of the language

2. Depending on the construct translate the code to target code

3. Use the constructs of the language to (in an editor) highlight parts
   differently

4. Source code processing like indenting, linting,


Keeping the programs text is not very convenient.


1. Some syntax is just sugar
   e.g [1,2,3] is a sugar for 1 :: 2 :: 3 :: []

2. Program text needs to worry about things like precedence whereas
   the representation that we see need not worry.

** Abstract syntax of the language

This is a term used mainly in programming language theory.

- Parse tree  - compiler literature
- Abstract syntax tree

Consider the language of expressions with + and * and constants (integers)

#+BEGIN_EXAMPLE
1 + 2 * 3

(1 * 2) + 3

(1 + 2) * 3

1 +   -- not an expression
1 3   -- not an expression

(1 + 2) 3 -- not an expression

#+END_EXAMPLE

- Concrete syntax ::

1. Governs what string/text is valid program
2. We want to know "how" the string is a member of the language. x ∈ L
3. We need ways to ensure that the grammar is unambiguous
4. Used to convert from "textual" representation of
   the program to .... abstract syntax or parse trees


#+BEGIN_EXAMPLE

E -> nat    -- nat rule
  |  E + E  -- plus rule
  |  E * E  -- mul rule   has more precedence
  | ( E )   -- paren rule


Proof that 1 + 2 * 3 is an E  --- 1 + {2 * 3}

(1) 1 is an E  (nat rule)
(2) 2 is an E  (nat rule)
(3) 3 is an E  (nat rule)
(4) 2 * 3 is an E (mul using 2,3)
(5) 1 + 2 * 3 is an E (plus using 1,4)


Proof that 1 + 2 * 3 is an E   {1 + 2} * 3

(1) 1 is an E  (nat rule)
(2) 2 is an E  (nat rule)
(3) 3 is an E  (nat rule)
(4) 1 + 2 is an E (plus using 1,2)
(5) 1 + 2 * 3 is an E (mul using 3,4)

#+END_EXAMPLE


Expressing expressions as trees will not have a problem of ambiguity.

#+BEGIN_EXAMPLE

         1 + {2 * 3}          {1 + 2} * 3

             +		           *
            / \		          / \
           1   * 		       	 +   3
              / \		      	/ \
             2   3	               1   2


#+END_EXAMPLE


- Abstract syntax ::

#+BEGIN_EXAMPLE

E -> nat
   | E + E
   | E * E

#+END_EXAMPLE

1. A nat is an expression

2. If E1 and E2 are expressions then E1 + E2 is an expression

3. If E1 and E2 are expressions then E1 * E2 is expression

#+BEGIN_SRC sml
datatype expr = Const of int
              | Plus  of expr * expr
              | Mul   of expr * expr


fun exprDenote (Const x)      = x
  | exprDenote (Plus (e1,e2)) = exprDenote e1 + exprDenote e2
  | exprDenote (Mul (e1,e2))  = exprDenote e1 * exprDenote e2

(* instruction of a stack machine *)
datatype inst = push of int
              | plus
              | mul


(*

push x :  pushes x on top of the stack

plus : x1 = pop x2 = pop ; push (x1 + x2)

mul  : x1 = pop x2 = pop ; push (x1 * x2)


*)
type executable = inst list

type stack = int list

(* instDenote : inst -> stack -> stack *)
fun instDenote (push x) stk                 = x :: stk
  | instDenote plus     (x1 :: x2 :: stk)   = x1 + x2 :: stk
  | instDenote mul      (x1 :: x2 :: stk)   = x1 * x2 :: stk

fun interp prog stk = fold....

(* compile : expr -> executable *)
fun compile (Const x)       = [push x]
  | compile (Plus (e1,e2))  = let val prog1 = compile e1
                                  val prog2 = compile e2
                              in
                                 prog2 @ prog1 @ [plus]
                              end

  | compile (Mul  (e1,e2))  = let val prog1 = compile e1
                                  val prog2 = compile e2
                              in
                                 prog2 @ prog1 @ [mul]
                              end

val one = Const 1
val two = Const 2
val three = Const 3
val x = Plus (Plus (one, two), three)
val p1 = compile x
#+END_SRC

#+RESULTS:
: datatype expr = Const of int | Mul of expr * expr | Plus of expr * expr
: datatype inst = mul | plus | push of int
: type executable = inst list
: val compile = fn : expr -> inst list
: val one = Const 1 : expr
: val two = Const 2 : expr
: val three = Const 3 : expr
: val x = Plus (Plus (Const #,Const #),Const 3) : expr
: val p1 = [push 3,push 2,push 1,plus,plus] : inst list

Abstract syntax

1. Only captures the essence of the syntax
2. Brackets and other disambiguation things can be removed.


#+BEGIN_EXAMPLE

S -> nat
  |  nat , S

#+END_EXAMPLE

#+BEGIN_SRC sml

type commaSepNat = int list

#+END_SRC
* DONE Structures and functors                                    :CLASSROOM:

** Main Idea

Main idea :: Control the name-space of definitions.

1. Possibly multiple instances of name vs value binding

2. Together with functor it gives powerful way of manipulating name space.
#+BEGIN_SRC sml

val x = 10
val x = "hello"

structure A = struct
   val  x   = 10
   type foo = int
end
(*

Modules in ocaml.

*)

val y = A.x
fun myfun (x : A.foo) = x + 1

open A (* generaly discouraged *)
fun myanotherfun (x : foo) = x + 1

val u = List.map myfun [1,2,3]

#+END_SRC

#+RESULTS:
#+begin_example
val x = <hidden-value> : int
val x = <hidden-value> : string
structure A :
  sig
    val x : int
    type foo = int
  end
val y = 10 : int
val myfun = fn : foo -> int
opening A
  val x : int
  type foo = int
val myanotherfun = fn : foo -> int
val u = [2,3,4] : int list
#+end_example

Caution

1. Do not confuse this with structures in C. In C structs are just
   product types which in SML is called records.

2. Similar to namespace in C++

** Signatures


1. Signatures can used to control what is exposed from a structure.

2. Signatures itself can be defined and used

3. Signature is used in functors to control what structures are expected to have.


#+BEGIN_SRC sml

signature MYSIG = sig
   type foo
   val  x : foo
 end

structure A : MYSIG

(* sig
   val x : int
   type foo
  end *) =  struct

val x = 10
val y = 100
type foo = int
type bar = string
end

val y = A.x  (* this is fine *)
(* val z = A.y  (* not fine as y is not exposed *) *)


structure B : MYSIG = struct

  type foo = string
  val x    = "hello"

end

#+END_SRC

#+RESULTS:
: signature MYSIG =
:   sig
:     type foo
:     val x : foo
:   end
: structure A : MYSIG
: val y = 10 : foo
: structure B : MYSIG


** An analogy with values and types


| Value world            | Structure world                  | Ocaml        |
|------------------------+----------------------------------+--------------|
| values (val)           | structures (structure .. struct) | module       |
| types  (type/datatype) | signatures (signature .. sig)    | module types |
| functions (fun)        | functor                          | functor      |


** Functors take structures and produce other structure.

#+BEGIN_SRC sml

datatype CMP = LT | GT | EQ

signature ORD = sig
  type t
  val compare : t -> t -> CMP
end


structure IntOrd : ORD = struct
  type t = int
  fun compare x y = ...
end


functor Invert ( O : ORD ) = struct
   type t = O.t
   fun compare x y = O.compare y x
end

struct InvIntOrd = Invert (IntOrd)

functor Sort (O : ORD) = struct
   fun sort (xs : O.t list) = ....

end

#+END_SRC

#+RESULTS:
#+begin_example
datatype CMP = EQ | GT | LT
signature ORD =
  sig
    type t
    val compare : t -> t -> CMP
  end
functor Invert(O: sig
                    type t
                    val compare : t -> t -> CMP
                  end) :
              sig
                type t
                val compare : O.t -> O.t -> CMP
              end
#+end_example


** General facts

1. Structures/functors are unique to ML and its dialect. But they can
   be retrofitted to any language.

2. One can defunctorise the code, i.e. take a program with structurs
   and functors and rewrite it to get code that is without them.  In
   fact the first phase of MLton compiler is precisely this.

3. structure/functors are what are know as zero-cost
   abstraction. There is no cost at runtime (space or time) for using
   the feature structure/functors. Maybe compile time will increase.


* DONE Structures and funtors continued                           :CLASSROOM:


** Some interesting libraries

1. Look for utility functions in the Standard Basis library

#+BEGIN_SRC sml

open Array

val myintarray = array (10, 42)
val mystrarray = array (10, "The answer is")
val _ = update (myintarray, 0, 100)

#+END_SRC

#+RESULTS:
#+begin_example
opening Array
  type 'a array = 'a ?.array
  type 'a vector = 'a ?.vector
  val maxLen : int
  val array : int * 'a -> 'a array
  val fromList : 'a list -> 'a array
  val tabulate : int * (int -> 'a) -> 'a array
  val length : 'a array -> int
  val sub : 'a array * int -> 'a
  val update : 'a array * int * 'a -> unit
  val vector : 'a array -> 'a vector
  val copy : {di:int, dst:'a array, src:'a array} -> unit
  val copyVec : {di:int, dst:'a array, src:'a vector} -> unit
  val appi : (int * 'a -> unit) -> 'a array -> unit
  val app : ('a -> unit) -> 'a array -> unit
  val modifyi : (int * 'a -> 'a) -> 'a array -> unit
  val modify : ('a -> 'a) -> 'a array -> unit
  val foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val foldl : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val foldr : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val findi : (int * 'a -> bool) -> 'a array -> (int * 'a) option
  val find : ('a -> bool) -> 'a array -> 'a option
  val exists : ('a -> bool) -> 'a array -> bool
  val all : ('a -> bool) -> 'a array -> bool
  val collate : ('a * 'a -> order) -> 'a array * 'a array -> order
  val toList : 'a array -> 'a list
  val fromVector : 'a vector -> 'a array
  val toVector : 'a array -> 'a vector
val myintarray = [|100,42,42,42,42,42,42,42,42,42|] : int array
val mystrarray =
  [|"The answer is","The answer is","The answer is","The answer is",
   "The answer is","The answer is","The answer is","The answer is",
   "The answer is","The answer is"|] : string array
#+end_example

2. Additional utility functions and libraries are available as part
   of the SML of NL library. This is also available in mlton

** Unique value creation

1. Not Globally unique but unique in a particular run of the computation.


#+BEGIN_SRC sml

datatype order = LESS | GREATER | EQUAL

signature UNIQUE = sig

   type uniq

   val new : unit -> uniq

end

(* opaque signature *)
structure Unique :> UNIQUE = struct
  type uniq = int

  val uniqRef = ref 0

  (* wrong implementation *)
  fun new () = 10 (* fixme *)



end

val x = Unique.new ()
(* val y = [x, 42] *)



(* Problem: Nothing gurantees that all the unique
   values that I created in the program is via Unique.new ()
 *)


#+END_SRC

#+RESULTS:
: datatype order = EQUAL | GREATER | LESS
: signature UNIQUE =
:   sig
:     type uniq
:     avl new : unit -> uniq
:   end
: structure Unique : UNIQUE
: val x = - : Unique.uniq


2. Atom implementation

A representation for variables in programs.

#+BEGIN_SRC sml

signature ATOM = sig

   type atom

   val atom  : string -> atom
   val toString : atom -> string

   val compare : atom * atom -> order

....
end

structure Atom :> ATOM = struct

   type atom = int

   val atomRef = ref 0

   (*
   1. A referencce to map from int (atom) -> string

   2. A reference to a map from string -> int (atom)

   *)

   type toStringMap = string IntRedBlackMap.map
   type atomMap     = atom StringRedBlackMap.map

   val toStringRef : ref toStringMap = ref IntRedBlackMap.empty
   val atomMap     : ref atomMap     = StringRedBlackMap.empty

   fun atom str = let val toStrMP = !toStringRef
                   (* loopkup the given str in toStrMP
                      1. It is already there in which case return the associated atom (int)
                      2. otherwise increment atomRef and assign str to this new value
                    *)

   fun toString atm = lookup
end

#+BEGIN_SRC sml

(* int -> int *)

val const ( _ : int) = 0
val incr x = x + 1


(* Given a function of type 'a -> 'a, 'a -> 'b -> 'a , int -> b -> int  *)

fun foo x = x

#+END_SRC

Benign side effect :: A side effectful computation that can be treated
like a pure computation The atom and toString functions of the Atom
structure look pure outside the structure although internally they
have side effect.


#+END_SRC
* DONE Lambda calculus and computability                          :CLASSROOM:

** Local declarations (non-recursive let).


#+BEGIN_SRC sml
fun foo x = let val y = x + 1
            in y * x
            end

#+END_SRC

#+RESULTS:
: val foo = fn : int -> int

#+BEGIN_EXAMPLE

let v = e1
in e2

===

(λ v . e2) e1

(fn v => e2) e1

....x = .. (let x = e1 in e2) ....

   The x in the expression e1 will be coming from
the outside scope

#+END_EXAMPLE

One can think of ~let v = e1 in e2~ as a syntactic sugar for
~(λ v . e2) e1~


Non-recursive let explanation
#+BEGIN_EXAMPLE

      <-----------
                 |
        (let x = x + 1 in .... x ...)
             ^                 |
             +-----------------+


  (let x = 5
     in
       let x = x + 1  (* this binds x to 5 + 1 = 6 *)
          in x        (* x here is 6 *)
       end
     end
  )

  This entire expression evaluates to 6
#+END_EXAMPLE

In OCAML there is ~let~ and ~let rec~

** Recursion and Fixpoints

1. Every lambda calculus expression is a function

2. A fixpoint of a function say F is a value X such that F X = X.

*** Fixpoint theorem

1. Every *closed* lambda calculus function has a fixed point.


2. This fixpoint is effectively computable. There is a λ-calculus
   combinator ~Y~ such that for all closed lambda calculus expressions
   ~F~, ~YF~ is the fixed point of ~F~.

- Closed expressions :: Expressions without free variables
- Combinator  :: Another name for closed expression.

- Consequence of part 1 :: In terms of recursive definition this means
     that any recursive definition of a function can be achieved
     through computing the appropriate fixpoint.

- Consequence of part 2 :: Think of a compiler that takes your
     favourite programming language and converts it into
     λ-calculus. The second part allows you to write such a compiler
     for recursive definitions.

     For a recursive equation like fact this means that you can write
     it as.

#+BEGIN_EXAMPLE
let F = fn f => fn n => if n <= 0 then 1 else n * f (n - 1)
   in let fact = Y F
          in  ....
          end
   end
#+END_EXAMPLE

Only closed expressions have meanings completely determined. In general,
the value associated with an expression depends on its free variable.

~λ x . x~ :: This is the identity function.

~x~ :: The value is determined only when the value of x is determined.


*** Fix points gives recursion.

1. letrec f x = ... f y .... in e

   F = λ f x . .....f y .....

#+BEGIN_SRC sml

fun fact n = if n <= 0 then 1
             else n * fact (n - 1)

val y = fact 4 (* this is just to check fact *)


fun F f n = if n <= 0 then 1 else n * f (n - 1) (* notice there is no recursion *)

val G = fn f => fn n => if n <= 0 then 1 else n * f (n - 1)

#+END_SRC

#+RESULTS:
: val fact = fn : int -> int
: val y = 24 : int
: val F = fn : (int -> int) -> int -> int
: val G = fn : (int -> int) -> int -> int
                  A               A

#+BEGIN_EXAMPLE

fact = λ n . if n <= 0 then 1 else n * fact (n - 1)

We want fact to be a solution of the above recursion


F = λ f . λ n . if n <= 0 then 1 else n * f (n - 1)

g is the fixpoint of F

This means g satisfies the recursion

   g = F g

g = (λ f . λ n . if n <= 0 then 1 else n * f (n - 1)) g
  = λ n . if n <= 0 then 1 else n * g (n - 1)

Solution of the recursion
 f = M (f)
 is the fixpoint of  λ f . M (f)

#+END_EXAMPLE

1. What is the fixpoint of ~F~ if it exists ?

   The fixpoint of ~F~ is that ~X~ such that ~F X = X~.

   ~F X is fn n => if n <= 0 then 1 else n * X (n - 1)~

   ~F X = X~ means ~X = F X~ which means

   ~X = fn n => if n <= 0 then 1 else n * X (n - 1)~
   ~fact = fn n => if n <= 0 then 1 else n * fact (n - 1)~

2. The recursive function definition ~fact~ is nothing but the fixpoint of
   The function ~F = fn f => fn n => if n <= 0 then 1 else n * f (n - 1)~


3. Notice that ~F~ is not recursive but its fixpoint is the solution to
   the recursive equation for ~fact~.

*** Proof of fixpoint theorem

1. We want the fixpoint of F

    θ = fn x => F (x x)

    θ θ = (fn x => F ( x x)) θ

        ⇒(β-reduces) F (x x) [ x := θ ]

        = F (θ θ)

        This proves that θθ is the fixpoint of F because θθ = F (θθ)

    Note that F (x x) is different from ((F x) x)
2. The Y-combinator for computing fixpoint.

   Given F the fixpoint of F is (λ x . F ( x x ))(λ x . F (x x))

   Y is that function that maps F to (λ x . F ( x x ))(λ x . F (x x))

   Y = λ f .  (λ x . f (x x)) (λ x . f (x x))

   Y is the desired fixpoint combinator.

   Y F = (λ f .  (λ x . f (x x)) (λ x . f (x x))) F
       = (λ x . F (x x))(λ x . F (x x))
       which is the fix point of F by part 1.

*** Some fun fixpoint combinators.

#+BEGIN_SRC

θ = λ p . λ k . k (p p k)

P = θ θ

P F = θ θ F  =  (λ p . λ k . k (p p k)) θ F
             => (λ k . k (θ θ k)) F
             => F ( θ θ F)

θθ is a fixpoint combinator like Y.

θ =   λ n λ e λ r λ a λ  j .  j(neeraj)

P = θ θ θ θ θ

Claim is P is a fixpoint combinator.

P F = (λ n λ e λ r λ a λ  j .  j(neeraj)) θ θ θ θ F
    = (λ j . j (θ θ θ θ θ j)) F)

    = F (θ θ θ θ θ F)
    = F (P F)



#+END_SRC

* DONE Typed Lambda calculus                                      :CLASSROOM:
<2020-10-05 Mon>

** So far.

So far we have seen untyped lambda calculus. It is a Turing complete
programming language, i.e. any computation task can be solved using
lambda calculus. We can have a semi-decision algorithm for any
recursively enumerable language of {0,1}*.

Lambda calculus is a full-fledged programming language.

1. There are no bultin constants or types like integers.

Adding types to lambda calculus. Constants and functions (builtin).


** λ-calculii and types.

The thing of interest for us is judgements ~e : τ~ where ~e~ is a term
and ~τ~ is a type.


*** The world of types

1. Start with some basic types, for eg. ~nat~, ~bool~, ....

2. The function type ~τ₁ -> τ₂~

#+BEGIN_EXAMPLE

<type> := one of the basic types like nat bool etc
       | <type>₁ -> <type>₂          (* function type or arrow type *)


#+END_EXAMPLE

*** The world of terms.

(λ x : τ . e)

These judgements e : τ, what do they mean ?  2 : nat means that we
cannot "apply" 2 to anything.

Suppose you know that e : nat then

1. You can use e in any context that expects a nat.  e.g (e + 1) is
   allowed

2. You cannot use e where a nat is not allowed e.g. (e x) is not
   allowed.


The fact that e : nat rules out the use of e in certain context in a
λ-calculus term. Or in other words, consider any context where e occurs
in a λ-calculus term M, we can decide whether e is used like a nat or not.


*** Types as a specification to values.

The judgement e : nat should be seen as a /specification/ of the
"program" e.

1. A specification or spec is a property that the program satisfies.
   For example, for scheduling /fairness/, i.e  any process that is
   ready should be scheduled to run in a finite amount of time.

2. A spec for a sorting program is that it "sorts the list".

   - Non-contracting :: If x is the input to the sort program then
        length of x = length of (sort x).


*** There are two problems associated with types.

- Type checking :: Given a term ~e~ and a type ~τ~, can we derive the
                   judgement ~e : τ~.

- Type inference :: Given a term ~e~ compute a type ~τ~ such that ~e :
                    τ~ is derivable.


We have to give the type rules for the calculus that we are talking
about.




** Simply typed lambda calculus.


1. Types: Basic types + arrow types.

   τ := nat
     |  τ₁ -> τ₂


When we want to derive the judgement ~e : τ~, we need a typing
context, i.e.  We need as assumption a set of judgements ~Γ = { x :
τ₁, x₂ , τ₂ .... }~ for all free variables of ~e~.


Say I want to arrive at this conclusion.
~x : nat~

I cannot /assert/ ~x : nat~ unless I /know/ that ~x : nat~.

The judgement ~x : nat~ is only valid under the assumption ~x : nat~.

x : nat ⊢ x : nat


~Γ ⊢ e : τ ~  is to be read as the judgement ~e : τ~ is valid in the context ~Γ~

A typing context Γ is just a list of type assumptions on variables.

Γ = { x₁ : τ₁, ... xₙ : τₙ }.


** Rules of typing.

*** Syntax consists of

- Variables :: x, y , z ..
- Function application :: e₁ e₂ ,i.e. The function  e₁ applied on e₂
- function abstraction :: (λ x:τ . e)

*** Typing rules

**** Types

#+BEGIN_EXAMPLE

τ := nat
  | τ₁ -> τ₂ |

#+END_EXAMPLE


There should be a rule for all the three term construction rules.

- A General Rule looks like ::

  #+BEGIN_EXAMPLE

   Pre-cond1
   Pre-cond2
   ...
   Pre-condn

   =========================

   conclusion.


#+END_EXAMPLE

- VAR :: The variable rule.

  #+BEGIN_EXAMPLE


   ===================
    {x : τ} ⊢ x : τ

  #+END_EXAMPLE

  Under no pre-condition, we can derive the judgement x : τ under the context x : τ

- APP ::

  #+BEGIN_EXAMPLE

    Γ ⊢ e₁ : τ₁ -> τ₂
    Γ ⊢ e₂ : τ₁

    =======================

    Γ ⊢ e₁ e₂ : τ₂


  #+END_EXAMPLE

  - Pre-condition ::
     ~e₁ : τ₁ -> τ₂~ under the context ~Γ~ and
     ~e₂ : τ₁~ under the cotnext ~Γ~

  - Conclusion ::
    ~e₁ e₂ : τ₂~ under the context ~Γ~.
- ABS ::

  #+BEGIN_EXAMPLE

   Γ ∪ { x : τ₁ } ⊢  e : τ₂

   ==============================

   Γ ⊢ (λ x : τ₁ . e) : τ₁ -> τ₂

  #+END_EXAMPLE

  - Pre-condition :: With the assumption ~x : τ₁~ suppose I derive ~e : τ₂~ then
  - Conclusion  :: (λ x : τ₁ . e) : τ₁ -> τ₂
* TODO Typed Lambda calculus Contd                                :CLASSROOM:

** Typing rule review

We want to have a complete set of rules for forming the judgement ~e : τ~ for each
λ-calculus term ~e~

~Γ~ is a set of type assumptions (i.e. judgements of the kind ~x : τ~). Conclusions are always
of the form ~Γ ⊢ e : τ~ (I can derive the judgement ~e : τ~ from the set of type assumptions ~Γ~.

Every Rule looks like
#+BEGIN_EXAMPLE
Pre-conditions
===============
Conclusion

#+END_EXAMPLE


- VAR :: The variable rule for the judgement ~x : τ~.

  #+BEGIN_EXAMPLE


   ===================
    Γ ∪ {x : τ} ⊢ x : τ

  #+END_EXAMPLE
- APP :: The application rule for judgement ~e₁ e₂ : τ~

  #+BEGIN_EXAMPLE

    Γ ⊢ e₁ : τ₁ -> τ₂
    Γ ⊢ e₂ : τ₁

    =======================

    Γ ⊢ e₁ e₂ : τ₂


  #+END_EXAMPLE
- ABS :: The abstraction rule for judgement ~fun (x : τ₁) => e  : τ₁ -> τ₂

  #+BEGIN_EXAMPLE

   (Γ ∪ { x : τ₁ }) ⊢  e : τ₂

   ==============================

   Γ ⊢ (λ x : τ₁ . e) : τ₁ -> τ₂
  #+END_EXAMPLE

- Weakening ::

#+BEGIN_EXAMPLE

   Γ ⊢ e : τ
   ==========
   Γ ∪ {x : τ₁} ⊢ e : τ


#+END_EXAMPLE



~Γ ⊢ e : τ~, I can derive the type judgement ~e: τ~
given the assumption set ~Γ~

We are now talking about the ABS rule.

- Judgement that I want to derive ::
     ~(fun (x : τ₁) => e)  : τ₁ -> τ₂~

When can the above function i.e. (fun (x : τ₁) => e)
have the type ~τ₁ -> τ₂~ ?
- Answer :: only when I have the pre-conditon that
            e : τ₂ under the assumption x : τ₁

** Some proofs of judgements.

A proof of a judgement should be a list of judgements of the kind Γ ⊢ e : τ₁. where

J₁ (R₁) ,J₂ (R₂),...,Jₙ (Rₙ)

(1) Rᵢ's are one of the instatiations of the the rule VAR, ABS, APP.

(2) every judgement Jᵢ follows from a set of judgements { Jₗ : l < i}  using one of the VAR,ABS or
    APP rule.


Jₙ is the judgement  (fun x : int => fun y : bool => x) : int -> bool -> int


1. ~x : int            ⊢ x : int~
                                   (VAR)
2. ~x : int, y : bool  ⊢ x : int~
                                  (VAR | WEAKENING (1) )

3. ~x : int            ⊢ (fun y : bool => x)  : bool -> int~
                                  (ABS (2))

4. ~⊢ fun (x : int) => fun (y : bool) => x) : int -> bool -> int~
                                  (ABS (3))
Γ ∪ x : τ₁ ⊢ e : τ₂
====================
Γ | (fun x : τ₁ => e) : τ₁ -> τ₂

#+END_EXAMPLE

In the case of 3 what is Γ ?
- Answer :: { x : int }
What is e is ?
- Answer :: (fun y : bool => x)

What is τ₁ ?
- Answer :: bool

What is τ₂ ?
- Answer :: int

What is x ?
- Answer :: y


** Exercise

Prove the judgement ~⊢ (fn x : nat => fn y : bool => x) 3 true : nat~

You can also use the additional Rules

#+BEGIN_EXAMPLE

===========           (TRUE-rule)
 true : bool

===========          (FALSE-rule)
 false : bool

===========  (NAT-n rule for each natural number n)
  n : nat

#+END_EXAMPLE

#+BEGIN_EXAMPLE
λ x y . x y  is same as λ x . λ y . x y

fn x y => x y   is same as fn x => (fn y => x y)

#+END_EXAMPLE
* Information.
- Youtube play list ::
https://www.youtube.com/playlist?list=PLhMQ0_-r9W5-LeXeXQtW8UcmtdJk98hfH

- Repository ::
https://bitbucket.org/piyush-kurur/popl



* DONE Functional Programming - Getting started                     :LECTURE:
- Video :: https://www.youtube.com/watch?v=slmy8JH5Llo

Language that we will use is Standard ML (SML)

ML stands for Meta Language

** SML/NJ - New Jersey

- Interpreter
- Is quick to use
- Is good for interactive sessions
- Standalone programs can be written but not recommended.

*** Installation

#+BEGIN_SRC
sudo apt intall smlnj      # the smlnj system.
sudo apt install rlwrap    # for adding history support for sml
sudo apt install sml-mode  # for emacs
#+END_SRC

** Mlton

- Full program optimising compiler
- Is slow to use (the compilation process is slow)
- Produces standalone fast executables


*** Installation

#+BEGIN_SRC
sudo apt install mlton

#+END_SRC

*** Compiling code

#+BEGIN_SRC
mlton foo.hs # produces the foo executable
./foo        # run the executable

mlton -output myprog foo.hs # generate executable in myprog
./myprog

#+END_SRC

** Tale of two SML's
 - For interactive use smlnj
   - on terminal or in emacs

 - for standalone compiling use mlton

* DONE Standard ML Programming model                                :LECTURE:
- Video :: https://www.youtube.com/watch?v=WoVXpQkhVhw
- Video :: https://www.youtube.com/watch?v=QVxqTi8iCzw&t=5s

- The mental model of what programs are and what they do

- This need not be the way in which the language is really
  implemented.

** C programming model

- C programs have a set of variables  which are memory cells
- Assignment statements update these cells
- Programs are essentially such statements
- Computation happens by running these statements in a sequence.





** SML programming model

*** Programs are variable bindings

#+BEGIN_SRC sml
val x = 10     (* binds x to the value 10 *)
val y = x + 2  (* it evalutes x + 2 and binds it to y *)
val z = x + y

(* Binding looks like

val <variable> = expression

*)

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 12 : int
: val z = 22 : int

**** Commentary

#+BEGIN_SRC  sml
val x = 10
(*
   1. 10 is itself a value so no reduction.
   2. x gets bound to 10
*)

val y = x + 2
(*
  RHS is x + 2 -----> 10 + 2 ---> 12

  y gets bound to 12

*)
val z = x + y

(*
RHS is x + y ---> 10 + y ----> 10 + 12 ---> 22

z gets bound to 22

*)

#+END_SRC

*** Computations happen when expressions are evaluated.


1. When variables are encountered during evalution, the corresponding
   value is substituted for it and the evaluation process continues.

**** Expressions (examples)

- 2
- 3 + 100
- x
- "hello"
- print "hello"

**** Values and reductions.

A subset of expressions are designated as values and are considered
in their simplest form (normal form).

Anything that is not a value needs simplification (reduction).

#+BEGIN_SRC

3 + (10 * 2) ---->  3 + 20 ---> 23 which is value

x --> We need to look up at that point what is the value bound to x

#+END_SRC




*** SML programs are just bindings.

1. A program is a list of bindings
2. Each binding defines a variable and associates it with a value
3. The value associated to a variable is obtained by
   reducing/simplifying the RHS.
4. Computations happen while these reductions are done.

** Pure values vs evaluation with side effects.

#+BEGIN_SRC sml

val x = print "hello\n"
val y = ()
#+END_SRC

#+RESULTS:
: hello
: val x = () : unit
: val y = () : unit

1. x gets bound to the value ~()~ - unit or hermit
2. When ~print "hello\n"~ is reduced, it results in "hello" being printed
   on the terminal.
3. The value obtained in this case ~()~ does not reflect this side effect.
4. The evaluation of ~print "hello\n"~ results in a side effect of printing
   the string ~"hello"~

In that sense ~print "hello"~ is /not/ a /pure value/

In general it is always preferable to use pure values and use
side-effects only when necessary.



* DONE Types                                                        :LECTURE:
- Video :: https://youtu.be/qC4RkYatlC0

** SML is a typed programming language

#+BEGIN_SRC sml
val x     = 10
val hello = "hello"
val y     = (1,"hello")
val z     = [1,2,3]
val z1    = ["hello", "world"]
(*

x : T   means x has the type T

*)
#+END_SRC

#+RESULTS:
: val x = 10 : int
: val hello = "hello" : string
: val y = (1,"hello") : int * string
: val z = [1,2,3] : int list
: val z1 = ["hello","world"] : string list

** Types rule out certain programs.


#+BEGIN_SRC  sml
val x = 2 + "hello"

#+END_SRC

#+RESULTS:
: stdIn:32.5-32.20 Error: operator and operand don't agree [overload conflict]
:   operator domain: [+ ty] * [+ ty]
:   operand:         [+ ty] * string
:   in expression:

** Types are taken seriously (strongly typed)


#+BEGIN_SRC sml

val x = 2.5
val z = 2
val y = x * 2

#+END_SRC

#+RESULTS:
: stdIn:48.5-48.14 Error: operator and operand don't agree [overload conflict]
:   operator domain: real * real
:   operand:         real * [int ty]
:   in expression:


** Strict types are great for safety

Write a program to take two numbers and compute its average.

*** In C

#+BEGIN_SRC C

# include<stdio.h>
double average( double x , double y )
{
   return 1.0/2.0 * (x + y);
}

int main ()
{
   printf("%g", average(2,3));
   return 0;
}

#+END_SRC

#+RESULTS:
: 2.5


*** In SML

#+BEGIN_SRC sml

fun average x y = 1.0/2.0 * (x + y)

#+END_SRC

#+RESULTS:
: val average = fn : real -> real -> real

* DONE Functions                                                    :LECTURE:
- Video :: https://youtu.be/IVeW5wv0wcA

** Definition of functions
#+BEGIN_SRC sml
fun identity x = x
fun increment x = x + 1
val z = identity 10
val helo = identity "hello"
val foo  = identity [1,2,3]
fun idInt (x : int)  = x

(*

The type of functions form A to B is A -> B
'a is a type variable.
*)
#+END_SRC
#+RESULTS:
: val identity = fn : 'a -> 'a
: val increment = fn : int -> int
: val z = 10 : int
: val helo = "hello" : string
: val foo = [1,2,3] : int list
: val idInt = fn : int -> int


- identity is a polymorphic function
- SML takes care of inferring the types of arguments and results.
- It infers the most general type possible

** Only single argument functions

- SML supports only single argument functions

- Recall :: If A and B are types then A -> B denotes the type
            of all functions from A to B

- Associativity of "->" :: It associates towards right
     ~A -> B -> C  === A -> (B -> C)~

*** Curried form

#+BEGIN_SRC sml

fun add x y = x + y

(* add takes a single argument x and returns a function that takes a single argument y
  and returns x + y
*)

val increment = add 1
#+END_SRC

#+RESULTS:
: val add = fn : int -> (int -> int)

*** Uncurried form

- A * B is the cartesian product of types A and B.
- elements of A * B are pairs (a,b) such that a : A and b : B
#+BEGIN_SRC sml

val z = (1, true)
val u = (1.0, 1, "hello")
fun add (x,y) = x + y

#+END_SRC

#+RESULTS:
: val z = (1,true) : int * bool
: val u = (1.0,1,"hello") : real * int * string
: val add = fn : int * int -> int


*** Conversion

#+BEGIN_SRC sml

(* curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c *)
fun curry f x y = f (x,y)
fun uncurry f (x,y) = f x y

#+END_SRC

#+RESULTS:
: val curry = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
: val uncurry = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c


* DONE Revisiting Types and Values                                  :LECTURE:

- Video :: https://youtu.be/gWz-UTGFoCI
- Video :: https://youtu.be/oqNi4F74vGk

** Why types ?

Values come with types and they govern

1. How we create values

2. How we make use of values

#+BEGIN_EXAMPLE

f : A -> B

x : A

y : B

z : C


1. f x  is okey because x is of type A and f expectes its argument to be of
   type A.  The expression f x itself is of type B


2. f y is not not okey because f was given an argument which is not its domain

#+END_EXAMPLE

- Type checking is checking whether your program violates any of the typing rules

- Type checking can catch a lot of programming bugs


|                       | Strong | Weak       |
|-----------------------+--------+------------|
| Static Type Checking  | SML    | C          |
| Dynamic Type Checking | Ruby   | JavaScript |


- Strong/Weak :: How strictly types are enforced

- Static Type checking :: The code is checked for type errors in the compilation phase
                          Nothing is done at run time

- Dynamic Type checking :: The type checking happens at run time

** Advantages of Static type checking

1. Type checking helps in finding bugs and the earlier the better

2. Since type checkings is already done the code generated can be much
   more efficient

3. SML has type inference that gives the language a feel of a
   Dynamically type checked language like ruby but gives the safety of
   a Statically type checked language.

** Basic types in SML

#+BEGIN_SRC sml
val anInt = 1
val aString = "hello"
val aChar   = #"c"
val aReal   = 2.0
val aBool   = true
val anotherBool = false
#+END_SRC

#+RESULTS:
: val anInt = 1 : int
: val aString = "hello" : string
: val aChar = #"c" : char
: val aReal = 2.0 : real
: val aBool = true : bool
: val anotherBool = false : bool

** Cartesian product of types

#+BEGIN_SRC sml
val x = (1, 2.0)
val y = ("hello", 2, true)
val z = (x,y)

val (u,v) = z  (* pattern matching
                  bind the variables u and v such that the pair (u,v) is z
                  SML sloves for u and v such that (u,v) = z in this case
                  *)

#+END_SRC

#+RESULTS:
: val x = (1,2.0) : int * real
: val y = ("hello",2,true) : string * int * bool
: val z = ((1,2.0),("hello",2,true)) : (int * real) * (string * int * bool)
: val u = (1,2.0) : int * real
: val v = ("hello",2,true) : string * int * bool

- A * B  :: The set theoretic Cartesian prodcut

A*B consists of values (a,b) where a : A and b : B

** Lists

#+BEGIN_SRC sml
val x1 = []
val x = [1,2,3]
val z = [true,false,false]
val y = 42 :: x   (* y is 42 followed by x *)
(* y is that list whose first element is 42 and the rest of the list is x *)


(* val foo = [1 ,true ]  (* This is an error all elements should be of the same type *)  *)

#+END_SRC

#+RESULTS:
: stdIn:17.11-17.21 Error: operator and operand don't agree [overload conflict]
:   operator domain: [int ty] * [int ty] list
:   operand:         [int ty] * bool list
:   in expression:

- Polymorphism :: int list, bool list etc 'a list where 'a is a type variable
- All elements of a particular list should be of the same type
- Recursively defined type/Inductive type
** What are lists

Let 'a be any type then 'a list is defined as the type consisting of

I.  [] : 'a list
II. If x : 'a and xs : 'a list then (x :: xs) : 'a list
III. The smallest collection of such values constitute the type 'a list

#+BEGIN_SRC sml
  val y = [1,2]       (* This is a syntactic sugar for the one below *)
  val x = 1 :: 2 :: []
  val u :: us = x  (* pattern matching for list *)

  (* If possible find bindings for u and us such that u :: us is the
  same as x *)
  (* val v :: vs = []  *)

  val z = [ (1,true) , (2, false) ]
  val (r,s)::ls = z

#+END_SRC

#+RESULTS:
: val y = [1,2] : int list
: val x = [1,2] : int list
: val u = 1 : int
: val us = [2] : int list
: val z = [(1,true),(2,false)] : (int * bool) list
: val r = 1 : int
: val s = true : bool
: val ls = [(2,false)] : (int * bool) list


i.  [] : int list

ii. 2 : int and [] : int list (from i) so 2 :: [] : int list (From
    rule II)

iii. 1 : int and 2:: [] : int list (from ii) and hence 1 :: 2 :: [] :
     int list (From rule II)


* DONE Pattern Matching                                             :LECTURE:

- Video :: https://youtu.be/GTPc4aPhXiQ
- Video :: https://youtu.be/RjHvrC51Hok

** What are patterns

1. Variables like ~x~ is pattern

2. Wildcard  ~_~ is a pattern (The underscore pattern)

3. If ~p1~ and ~p2~ are patterns then so is ~(p1,p2)~ and similarly for
   n-tuples

4. If ~p~ and ~ps~ are patterns then ~p :: ps~ is also a pattern

** Pattern matching.

Given an value ~v~, and a pattern ~pat~

1. Does ~pat~ match the value ~v~

2. What are the resulting variable bindings.

** Rules of pattern matching

+--------------------+-----------+---------------+-------------------------------------+
| Pattern            | Type of v | Form of the v |Bindings created                     |
+--------------------+-----------+---------------+-------------------------------------+
| Variable (say ~x~) | any type  | any value     | ~x = v~                             |
+--------------------+-----------+---------------+-------------------------------------+
| Wild card (~_~)    | any type  | any value     |No bindings created                  |
+--------------------+-----------+---------------+-------------------------------------+
| ~(p1,p2)~          | ~'a * 'b~ | ~(v1,v2)~     |match ~p1~ with ~v1~ and ~p2~ with   |
|                    |           |               | ~v2~                                |
+--------------------+-----------+---------------+-------------------------------------+
| ~p :: ps~          | ~'a list~ | ~(v :: vs)~   |matchs ~p~ with ~v~ and ~ps~ with    |
|                    |           |               | ~vs~                                |
+--------------------+-----------+---------------+-------------------------------------+
| ~[]~               | ~'a list~ | ~[]~          |no bindings created                  |
+--------------------+-----------+---------------+-------------------------------------+



1. The type checking is done (column 2) at compile time (statics)

2. Form of value (column 3) is checked at runtime.

#+BEGIN_SRC sml

val x :: xs = e  (* unless you reduce e there is no way to know
whether it is [] or is it v :: vs *)

#+END_SRC

*
** Functions via pattern matching.

#+BEGIN_SRC sml

(* fst : 'a * 'b -> 'a  *)
fun fst (x,_) = x
fun snd (_,y) = y

(* isEmpty : 'a list -> bool *)
fun isEmpty [] = true   (* 1 *)
  | isEmpty _  = false  (* 2 *)


(*  isEmpty [] ---- matches the first eqn so replace by the rhs ---> true

    isEmpty [1,2,3] == isEmpty (1 :: (2 :: 3 :: []))
             ---> does not match the eqn 1 so try eqn 2.
             y is bound to 1 and ys is bound (2 :: 3 :: [])

             ---> false

*)

(*

length : 'a list -> int

*)

fun length []         = 0
  | length (_ :: ys)  = 1 + length ys

(*
map f [x1,x2....,xn] = [f x1 , f x2 ...., f xn ]
*)

fun map f []        = []
  | map f (x :: xs) = f x :: map f xs

fun incr x = x + 1

val u = map incr [1,2, 3]

#+END_SRC

#+RESULTS:
: val fst = fn : 'a * 'b -> 'a
: val snd = fn : 'a * 'b -> 'b
: val isEmpty = fn : 'a list -> bool
: val length = fn : 'a list -> int
: val map = fn : ('a -> 'b) -> 'a list -> 'b list
: val incr = fn : int -> int
: val u = [2,3,4] : int list


* DONE Algebraic data types.                                        :LECTURE:
- Video :: https://youtu.be/TLej5OaXpgg
- Video :: https://youtu.be/oChjS-CuEqY
** Motivation

Often types are defined by enumerating all the possible values
in the type.

#+BEGIN_SRC sml

datatype mybool = True | False

val someBool = True

(*

not  : mybool -> mybool

*)
fun not True  = False
  | not False = True

#+END_SRC

#+RESULTS:
: datatype mybool = False | True
: val someBool = True : mybool
: val not = fn : mybool -> mybool


** Optional value

#+BEGIN_SRC sml

datatype 'a option = SOME of 'a | NONE

(*
headSafe  : 'a list -> 'a option
*)

fun headSafe (x :: _) = SOME x
  | headSafe []       = NONE

val x = headSafe []
#+END_SRC

#+RESULTS:
: stdIn:49.5-49.20 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: datatype 'a option = NONE | SOME of 'a
: val headSafe = fn : 'a list -> 'a option
: val x = NONE : ?.X1 option

** Recursive type.


#+BEGIN_SRC sml

datatype 'a mylist = Nil
                   | Cons of 'a * 'a mylist

fun embed Nil = []
  | embed (Cons (x,xs)) = x :: embed xs

fun revEmbed []         = Nil
  | revEmbed (x :: xs)  = Cons (x , revEmbed xs)

val my123 = revEmbed [1,2,3]
val y     = Cons (1, Cons (2, (Cons (3, Nil))))
val yl    = embed y

#+END_SRC

#+RESULTS:
: datatype 'a mylist = Cons of 'a * 'a mylist | Nil
: val embed = fn : 'a mylist -> 'a list
: val revEmbed = fn : 'a list -> 'a mylist
: val my123 = Cons (1,Cons (2,Cons #)) : int mylist
: val y = Cons (1,Cons (2,Cons #)) : int mylist
: val yl = [1,2,3] : int list


** Binary trees on 'a

1. An empty tree is a binary tree

1. If x : 'a and t1 and t2 are trees of type 'a then the tree with
   root being x and t1 and t2 being subtrees is also a tree

#+BEGIN_SRC sml

datatype 'a tree = empty
                 | node of 'a * 'a tree * 'a tree

(* inorder : 'a tree -> 'a list *)
fun inorder empty             = []
  | inorder (node (x,tL, tR)) = inorder tL @ [x] @ inorder tR

fun singleton x = node (x, empty, empty)

val t = node (2, singleton 1, singleton 3)
val y = inorder t

#+END_SRC

#+RESULTS:
: datatype 'a tree = empty | node of 'a * 'a tree * 'a tree
: val inorder = fn : 'a tree -> 'a list
: val singleton = fn : 'a -> 'a tree
: val t = node (2,node (1,empty,empty),node (3,empty,empty)) : int tree


** General form

#+BEGIN_SRC sml

datatype ('a, 'b, 'c) Name = C1
                           | C2 of sometype
                           | CN

#+END_SRC

1. Constructors are of two forms. Either ~C1~ or ~C2 of some type~

2. the types appearing on the rhs can refer to the type variables in the lhs, i.e 'a, 'b, 'c

3. The type can be recursive, i.e sometype can refer to Name itsef.


*** The consequence of a datatype definition

1. A new polymorphic type ~('a, 'b, 'c) Name~ is created

2. Constructors becomes functions.

#+BEGIN_EXAMPLE sml

C1 : ('a,'b,'c) Name
C2 : sometype -> ('a,'b, 'c) Name
C3 : ('a,'b,'c) Name

#+END_EXAMPLE

3. Constructors can be used in pattern matching involving values of
   the type Name.

   i. ~C1~ is a pattern of type ~('a, 'b, 'c) Name~
   ii. If ~p~ is a pattern of type something then ~C2 p~ is also a pattern
* DONE Structures, Signatures, Functors.                            :LECTURE:
- Video :: https://youtu.be/_AwO5d7WhPI
- Video :: https://youtu.be/bAGppGJjglQ
** Motivation

Controlling the scope of a name binding.

#+BEGIN_SRC  sml
val x = 10
type foo = int
datatype bar = biz | bhur
fun incr x = x + 1

structure A = struct
   type foo     = int
   val x    : foo = 42
   fun incr (y : foo) = y + 1
end

val z  = A.x
val z1 = x

#+END_SRC

#+RESULTS:
#+begin_example
val x = 10 : int
type foo = int
datatype bar = bhur | biz
val incr = fn : int -> int
structure A :
  sig
    type foo = int
    val x : foo
    val incr : foo -> int
  end
val z = 42 : foo
val z1 = 10 : int
#+end_example


** Explicit signatures and controlling exports


#+BEGIN_SRC sml

signature MYSIG = sig
   type foo
   val x : foo
end

structure A  : MYSIG
   = struct
       type foo = int
       val x : foo = 10
       val inner : foo = 42
     end

structure B : MYSIG
   = struct
         type foo = string
         val x   = "hello"
         val internalString = "The answer is 42"
     end
val z1 = A.x
val z2 = B.x

(*
val z2 = A.inner (* with explicit signatures inner is hidden and hence error *)

*)
#+END_SRC

#+RESULTS:
: signature MYSIG =
:   sig
:     type foo
:     val x : foo
:   end
: structure A : MYSIG
: structure B : MYSIG
: val z1 = 10 : foo
: val z2 = "hello" : B.foo

** Functors

- Main Idea :: Functors are "functions" on structures

#+BEGIN_SRC sml

datatype order = LESS | GREATER | EQUAL

signature ORD = sig
   type t
   val compare : t * t -> order
end

structure IntOrd = struct
   type t = int
   fun compare (x,y) = if x < y then LESS
                       else if x > y then GREATER
                            else EQUAL

end

functor InvertORD (O : ORD) : ORD = struct

   type t = O.t
   fun compare (x,y) = O.compare (y,x)

end

structure InvIntOrd = InvertORD ( IntOrd )

val tup = (3,3)
val z = IntOrd.compare  tup
val z1 = InvIntOrd.compare tup

#+END_SRC

#+RESULTS:
#+begin_example
datatype order = EQUAL | GREATER | LESS
signature ORD =
  sig
    type t
    val compare : t * t -> order
  end
structure IntOrd :
  sig
    type t = int
    val compare : int * int -> order
  end
functor InvertORD(O: sig
                       type t
                       val compare : t * t -> order
                     end) :
                 sig
                   type t
                   val compare : t * t -> order
                 end
structure InvIntOrd : ORD
val tup = (3,3) : int * int
val z = EQUAL : order
val z1 = EQUAL : order
#+end_example

** General remarks

1. We really need only values (types and functions) for programs

2. Structures gives modularity and abstraction for coding in large.

   - Reuse or overloading ::

        #+BEGIN_SRC sml


        functor Sort ( O : ORD ) : sig
           val sort : O.t list -> O.t list
          end
          = struct
            fun sort xs = xs
            end

        #+END_SRC

        #+RESULTS:
        : functor Sort(O: sig
        :                   type t
        :                   val compare : t * t -> order
        :                 end) :
        :             sig val sort : O.t list -> O.t list end

   - Abstract types :: Types which can only be processed in a specific way.

   - At the meta level :: This is not at the value level where the "real" programming happens.
        values, functions and types as your workers, then the structure/functors is the managers
        of these

   - Main Idea :: This is mostly for programming in large

3. The structure layer is similar to the values layer


| Value world                     | Structure layer                              |
|---------------------------------+----------------------------------------------|
| values (~val~)                  | structures (~structure~)                     |
| types (specs on values)         | signatures (specs on structures)             |
| functions maps values to values | functors (that map structures to structures) |

4. Structures give a zero cost abstraction.

   ML with structures is as efficient as ML without structures.
   In fact the mlton compiler first defunctorises (removes structures and functors).

5. SML like Structures can be added to any language (mostly)
   C with SML like structures.
* DONE Structures and functors in practice                          :LECTURE:

Video :: https://youtu.be/95UPSteFfTA
Video :: https://youtu.be/KhSN46EiiRU

** Standard Libraries.

Many data structures, utility functions, IO functions etc are
available with the standard library system of SML

1. [[https://smlfamily.github.io/Basis/manpages.html][Standard Basis Libaray]]

2. [[https://www.smlnj.org/doc/smlnj-lib/Util/smlnj-lib.html][SML of NJ library]]


*** Opening structures.

Opening structure brings the bindings inside the structure to the
current scope.

This is not really recommended as List.map is much more understandable
than just map when in particular you have say Tree.map as well.

#+BEGIN_SRC sml

val x = splitAt

val y = let open List
        in
           splitAt
        end

#+END_SRC

#+RESULTS:
: stdIn:12.5-15.12 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: val x = fn : 'a list * int -> 'a list * 'a list
: val y = fn : ?.X1 list * int -> ?.X1 list * ?.X1 list

** Case Study: Set data structure

Details: https://www.smlnj.org/doc/smlnj-lib/Util/sig-ORD_SET.html

Algorithms often need to maintain the set of objects of a given type

A set data-structure implementation gives a way to implement this with
efficient opertions like union, intersection etc.

SML of NJ library

There are multiple implementation for Int set given by

- IntBinarySet   :: using binary tree
- IntListSet     :: using lists
- IntRedBlackSet :: using red-black trees.


The ~ORD_SET~ signature gives you what all operations are defined.



*** Defining set data structure for your own type.


1. Define an structure K of signature ORD_KEY for your datatype

#+BEGIN_SRC sml

datatype order = LESS | GREATER | EQUAL

signature ORD_KEY = sig

    type ord_key

    val compare : ord_key * ord_key -> order
end

datatype Foo = ...

structure FooORD : ORD_KEY = struct
   type ord_key = Foo
   val compare (f1,f2) = ...
end

#+END_SRC

2. Use this K as parameter to one of the Set implementation functors.

   - ListSetFn
   - BinarySetFn

#+BEGIN_SRC sml

structure FooSet = RedBlackSetFn ( FooORD )

let emptyFooSet = FooSet.empty


#+END_SRC


** Map data structure

This is to store a finite map from keys to values.

- structure IntRedBlackMap

Details: https://www.smlnj.org/doc/smlnj-lib/Util/sig-ORD_MAP.html

* DONE Opacity in signatures                                        :LECTURE:

- Video :: https://youtu.be/UUsscUwqvMI

** Motivating example

#+BEGIN_EXAMPLE sml

signature ORD_KEY = sig
   type ord_key
   val compare : ord_key * ord_key -> ordering

end

signature ORD_SET = sig
  type set
  (* Some stuff here *)
end

#+END_EXAMPLE

#+BEGIN_SRC sml

functor BinarySetFn (O : ORD_KEY) :> ORD_SET = struct

  datatype set = empty
               | node of O.ord_key * set * set


  (* external functions *)
  fun union xs ys = ...

  (* some internal functions *)

  fun internal = ..

end

#+END_SRC

1. The implementation makes use of the order structure to maintain the set
   as a /binary search tree/.

2. This BST property is crucial for the correctness of the implementation. Say
   membership test is essentially a BST search.

3. Because the ~set~ type is exposed, outside the structure one can
   write functions on ~set~ (as it is a binary tree implementation)
   which does not keep track of the BST property.

4. Next time when one uses the same datatype it fails.

5. What we really want is to expose the type ~set~ but not anything
   more, i.e. we want the ~set~ type to be /abstract/

Opaque signature is for this.


- Howto :: Use ~structure A :> SIG~ instead of ~structure A : SIG~.

** Examples

#+BEGIN_SRC sml

signature SIG = sig
  type foo
  val x : foo
end

structure A : SIG = struct

   type foo = int
   val x = 4

end

structure B :> SIG = struct
   type foo = int
   val x = 42

end

val z  : int = A.x  (* recognises that A.foo which is the type of A.x is int *)
val z1 = B.x        (* B.x is of type B.foo which is different for int outside B *)

#+END_SRC

#+RESULTS:
: signature SIG =
:   sig
:     type foo
:     val x : foo
:   end
: structure A : SIG
: structure B : SIG
: val z = 4 : int
: val z1 = - : B.foo

** Translucence instead of Opaque

#+BEGIN_SRC sml

signature SIG = sig
  type foo
  type bar    = int
  val x : foo
  val y : bar

end

structure A :> SIG = struct
  type foo = int
  type bar = int
  val x = 42
  val y = 42
end

val z = A.y + 1   (* A.bar is transparent *)
val z1 = A.x + 1  (* is an error as A.foo is abstract type opaque *)
#+END_SRC

#+RESULTS:
: stdIn:128.5-128.17 Error: operator and operand don't agree [overload conflict]
:   operator domain: [+ ty] * [+ ty]
:   operand:         A.foo * [int ty]
:   in expression:


* DONE Lambda Calculus: The "core" of functional programming        :LECTURE:
- Video :: https://youtu.be/OH8mVopLJIs

** What all do we need for a minimal functional languages

- Variables :: x, y, ...

- Function applications ::  ~f e~

- Function abstraction :: ~fn x => e~ This denotes the function that maps ~x~ to ~e~


This is all that we need to get the full power of a programming
language.

There is a way to encode all possible computations by just these.

This was the observation of Church and is know as the Church Hypothesis.

Church used the notation ~λ x . e~ instead of ~fn x => e~.

#+BEGIN_SRC sml

val incr = fn x => x + 1

#+END_SRC
#+RESULTS:
: val incr = fn : int -> int

** Syntax

#+BEGIN_EXAMPLE

<expr> := <variable>
        |  <expr₁> <expr₂>          (function application )
        |  fn <variable> => <expr>  (function abstraction )
        | λ <variable> . <expr>     (Church's notation for abstraction)

fn x y => e   is a short hand for fn x => fn y => e

We will use paranthesis to disambiguate.
#+END_EXAMPLE


** Semantics

The computation is captured by the notion of β-reduction.

#+BEGIN_EXAMPLE

(fn x => e) M  ===>  e [ x := M].

(fn x => fn y => x) (fn t => t) =========>
   (fn y => x) [x := M] =======> fn y => (fn t => t)

#+END_EXAMPLE

~e [x := M]~ is the notation for substitute M for x in e.

Given a λ-calculus term, any subterm can be reduced using the
β-reduction rule. And this gives computation.


Keep reducing till a term is obtained which cannot be β-reduced.


** Complications in Substitutions.

Substitutions are complicated because of variable capture.

#+BEGIN_SRC

(fn x => fn y => x y) y ====> fn y => y y  (* wrong *)

(fn x => fn z => x z) y  ====> fn z => y z (* correct *)

#+END_SRC


* DONE Lambda Calculus: Revisiting substituions                     :LECTURE:

Video :: https://youtu.be/EwRr8JBhLbA

Systematic study and formalisation of the notion of substitution and
fix problems with β-reduction.

** Free and bound variables.

In an λ-calculus term any variable x that occurs in the /shadow/ of a
~fn x => ~ is a /bound variable/ otherwise it is /free/.

#+BEGIN_EXAMPLE

F (y) ≡ fn x => x y  ( x is bound but y is free )

I(y) ≡ ₀∫¹ x y dx   ( x is bound and y is free )

ψ (z) ≡ ∀ x ∃ y ϕ(x,y,z) ( x and y are bound where as z is free).

fun foo x = print x  (here x is bound but print is free).
#+END_EXAMPLE

- The "value" associated with the term depends on the free variables
  but not on the bound variables.

- The bound variables may be replaced by "fresh" variables.



#+BEGIN_EXAMPLE

F (y) ≡ fn x => x y = fn t => t y ( x is bound but y is free )

I(y) ≡ ₀∫¹ x y dx  = ₀∫¹ t y dt  ( x is bound and y is free )

ψ (z) ≡ ∀ x ∃ y ϕ(x,y,z) = ∀ t ∃ u ϕ(t,u,z) ( x and y are bound where as z is free).

fun foo l = print l  (here x is bound but print is free).
#+END_EXAMPLE

** Formal definition.

- FV(e) :: free variables of the λ-calculus expression e is a subset of variables
           defined by induction as follows.

  1. FV(x) = { x }

  2. FV(e₁ e₂) = FV(e₁) ∪ FV(e₂)

  3. FV(λ x . e) = FV(e) ∖ {x }


- Where do bound variables get bound.

#+BEGIN_EXAMPLE
fn x => (fn x => x) ≡  fn x₀ => (fn x₁ => x₁)
#+END_EXAMPLE

The innermost binding is the strongest.

*** Substitution e [x := M]

e [x := M] stands for the expression e' obtained by substituting M for all
free occurance of x in e.

- Variable Substitution rule ::

  1. x [ x := M ]  ≡ M

  2. y [ x := M ]  ≡ y  (if y ≠ x

- Substitution in application :: (e₁ e₂) [ x := M ] ≡ (e₁ [x := M]) (e₂ [x := M])

- Substitution in abstraction ::

     1. (λ x . e) [ x := M] = (λ x . e) (only substitute for free occurance)

     2. (λ y . e) [ x := M] = (λ y . e [x := M]) (if y ≠ x)

** β-reduction

#+BEGIN_EXAMPLE

(λ x . e) M ===> e [ x := M]

#+END_EXAMPLE


- Side condition :: No free variables of M should be bound in e

- α-reduction :: change the bound variables of e to fresh variables.

    (λ z . M) ===>  (λ u . M [ z := u ]) where u is fresh.



* DONE Typed lambda calculi                                         :LECTURE:

- Video :: https://youtu.be/O7-W3lVFAyI

I have used calculi (the plural) instead of the calculus.

** Introduction

- What are the Types :: This can be just simple types or
  much more complicated say involving polymorphism etc.

- Typing Judgements :: Let ~e~ be a term in the calculus and let ~τ~
     be a type. Judgements kill be assertions of the kind ~e~ has type
     ~τ~ Judgements are written in the notation ~e : τ~

- Typing rules :: These are a set of rules which tell you what judgements
                  your are allowed to make. These often come with pre-conditions
                  which are themselves judgements.

- Type checking problem :: Given an expression ~e~ and a type ~τ~,
     decide whether the judgement ~e : τ~ is a /valid judgement/ (as
     described by the typing rules) or not.

- Type inference problem :: Given an expression ~e~ compute a type ~τ~
  (if possible) such that ~e : τ~ is valid. If ~e~ is ill-typed, i.e if
  there is no τ such that ~e : τ~ is valid then report error.


** Typing judgement generalisation.

*** When is the judgement ~x : τ~ valid ?

We cannot decide on this without knowing ~x~.
We need to know the type of ~x~.

*** For terms.

The judgement ~e : τ~ can only be asserted under type assumptions on
free variables of ~e~


*** Generalisation.


- Type assumption :: A type assumption is a judgement of the kind ~x : τ~ for
     some variable ~x~.

- Judgement would be :: ~Γ ⊢ e : τ~ where Γ = { x₁ : τ₁, ... , xₙ : τₙ }
  is a set of type assumptions.

- Type checking/inference :: can be done only for the case when ~Γ ⊃ FV(e)~

- Typing rules will talk about this generalised judgements.


** Typing rules and proofs.


#+BEGIN_EXAMPLE

J₁
J₂
J₃
.
.
.
Jₙ
====================
J

#+END_EXAMPLE

In the rule above ~Jᵢ~, i.e. the judgements above the line, are called
the /pre-conditions/ and the judgement ~J~ is called the /conclusion/
of the rule.


#+BEGIN_EXAMPLE

Γ ⊢ f : τ₁ → τ₂

Γ ⊢ e : τ₁

============

Γ ⊢ f e : τ₂

#+END_EXAMPLE

*** A proof

Fix a set of rules R₁,... Rₖ.


A proof is a sequence of judgements that satisfy

- An empty sequence is a proof

- If γ = J₁,...,Jₙ is a proof and if Rᵢ is a rule which all its
  pre-conditions in γ, then the sequence J₁,...,Jₙ, J is also a proof
  where J is the conclusion of Rᵢ. (Applying the  rule Rᵢ).

A proof of a judgement J is just a valid proof whose last judgement is J.

* DONE Getting started                                                  :LAB:
SCHEDULED: <2020-08-06 Thu>

** Git

1. Installation

#+BEGIN_SRC
sudo apt install git tig gitk
#+END_SRC

2. Set your name and email id.

#+BEGIN_SRC

git config --global --edit

#+END_SRC

3. Make a local repository

#+BEGIN_SRC

mkdir code/git/ROLLNO-popl -p
cd code/git/ROLLNO-popl
git init
emacs README.md
git add README.md # Asks git to keep track of changes in this file from now own
git commit -m 'added readme' # This creates a commit with message "added readme"
# or one can avoid the -m option
git commit # will open an editor


#+END_SRC

4. Have a .gitignore file

Controls what files should be ignored by git

5. I often put a pre-commit hook

This is to avoid committing changes with trailing spaces.

#+BEGIN_SRC

# Go to the top of the repository
cd ~code/git/007-popl
mv .git/hook/pre-commit.sample .git/hook/pre-commit # Enable the pre-commit hook

#+END_SRC

6. Learn more about git and you can also use magit (git operations from emacs)


** Bitbucket stuff

1. Create account on bitbucket
2. Create a new repository in bitbucket
3. Push changes from local to bitbucket repository

#+BEGIN_SRC sh

# Create a link to the remote repository on bitbucket and call it origin.
git remote origin git@bitbucket.org:piyush-kurur/007-popl.git

# Push things here to bitbucket.
git push origin -u master

#+END_SRC


** Assignment Submission Workflow

1. Give readonly access to all TA's and me (piyush-kurur) (Using the webinterface of bitbucket)

2. Write your code in the repository (within the deadline) and commit
   it.

3. Push it to bitbucket.


** Few related things to try out

1. You can fork my popl repository on bitbucket
2. You should "Watch" my popl repository
3. You can clone repositories from (say) bitbucket
4. If the repository above is your own, then you can push stuff there.

* DONE SML Tutorial.                                                    :LAB:
* DONE Basic functions                                                  :LAB:

** Pattern matching on tuples.

#+BEGIN_SRC sml

val x     = (2, "hello") (* create a tuple *)
val (u,v) = x  (* binding by pattern matching *)
val (_,z) = x

(*
fun foo pattern = ....
*)


(*

fst : 'a * 'b -> 'a
snd : 'a * 'b -> 'b

foo (1 + 2)  ---> foo 3
             -- function call of foo --->
             let val pattern = 3 in ....

*)
#+END_SRC

#+RESULTS:
: val x = (2,"hello") : int * string
: val u = 2 : int
: val v = "hello" : string
: val z = 2 : int

** Patterns.

 1. A variable is a pattern
 2. An _ is a pattern
 3. If p1 and p2 are patterns then
    (p1, p2) is also a pattern
#+BEGIN_SRC sml

val x = 10
val _ = 10
val (p1,p2) = ...

#+END_SRC

#+RESULTS:
: stdIn:42.5-42.24 Error: pattern and expression in val dec don't agree [overload conflict]
:   pattern:    ('Z * 'Y) * 'X
:   expression:    [int ty] * [int ty]
:   in declaration:
** List patterns

'a is type

1. [] : 'a list
2. Suppose x : 'a  and  xs : 'a list then
   x :: xs is also an element of type 'a list


#+BEGIN_SRC sml

val x = [1,2,3]
val x1 = 1 :: 2 :: 3 :: []
(*  - [] is an int list
    - 3 is an int and [] is an int list so
    - 2 is an int and 3 :: [] is an int list


*)


(* isEmpty : 'a list -> bool *)
fun isEmpty []        = true
  | isEmpty (_ :: _) = false

val z = isEmpty [1,3,4]

(*  concat : 'a list -> 'a list -> 'a list

*)
fun concat (x :: xs) ys = x :: concat xs ys
  | concat []        ys = ys

val u = concat [1,2,3] [4,5 , 6]



#+END_SRC



#+RESULTS:
: val x = [1,2,3] : int list
: val x1 = [1,2,3] : int list
: val isEmpty = fn : 'a list -> bool
: val z = false : bool
: val concat = fn : 'a list -> 'a list -> 'a list
: val u = [1,2,3,4,5,6] : int list

#+BEGIN_SRC sml

fun append []       x = [x]
  | append (y :: ys) x = y :: append ys x

(* index : int -> 'a list -> 'a

*)
fun index ix xs = ...
(*

append [1,2,3] 4 => let val y = 1
                        val ys = [2,3]
                        val x  = 4
                    in y :: append ys x

  ---> 1 :: append [2,3] 4
  ---> 1 :: let val y = 2
                val ys = [3]
                val x  = 4
            in y :: append ys x

---> 1 :: (2 :: append [3] 4)
---> 1 :: 2 :: (let val y = 3
                    val ys = []
                    val x = 4
                in y :: append ys x
               )
--> 1 :: 2 :: (3 :: append [] 4)
--> 1 :: 2 :: ( 3 :: let val x = 4
                     in [x])

--> 1 :: 2 :: 3 :: [4]
= 1 :: 2 :: 3 :: 4 :: []
= [1,2,3,4]


*)

http://mlton.org/ValueRestriction

#+END_SRC
* DONE Fold functions
SCHEDULED: <2020-09-03 Thu>

#+BEGIN_SRC sml

open List

fun mynth n []        = NONE
  | mynth n (x :: xs) = if n > 0 then mynth (n-1) xs
                        else if n < 0 then NONE
                             else SOME x

val x = mynth 1 [1,2,3]

 (* partition : ('a -> bool) -> 'a list -> 'a list * 'a list *)
fun partition pred (x :: xs) = let val (tL , fL) = partition pred xs
                               in
                                  if pred x then ( x :: tL , fL)
                                  else           ( tL, x :: fL)

  | partition pred []        = ([] , [])

(* 'summary = 'a list * 'a list
    sfun : 'a * 'summary -> 'summary
    s0  = ([], [])
*)

fun partition pred xs = let fun sfun = ...
                        in foldl sfun s0 xs
                        end

#+END_SRC

#+RESULTS:
#+begin_example
opening List
  datatype 'a list = :: of 'a * 'a list | nil
  exception Empty
  val null : 'a list -> bool
  val hd : 'a list -> 'a
  val tl : 'a list -> 'a list
  val last : 'a list -> 'a
  val getItem : 'a list -> ('a * 'a list) option
  val nth : 'a list * int -> 'a
  val take : 'a list * int -> 'a list
  val drop : 'a list * int -> 'a list
  val length : 'a list -> int
  val rev : 'a list -> 'a list
  val @ : 'a list * 'a list -> 'a list
  val concat : 'a list list -> 'a list
  val revAppend : 'a list * 'a list -> 'a list
  val app : ('a -> unit) -> 'a list -> unit
  val map : ('a -> 'b) -> 'a list -> 'b list
  val mapPartial : ('a -> 'b option) -> 'a list -> 'b list
  val find : ('a -> bool) -> 'a list -> 'a option
  val filter : ('a -> bool) -> 'a list -> 'a list
  val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
  val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
  val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
  val exists : ('a -> bool) -> 'a list -> bool
  val all : ('a -> bool) -> 'a list -> bool
  val tabulate : int * (int -> 'a) -> 'a list
  val collate : ('a * 'a -> order) -> 'a list * 'a list -> order
  val unfoldl : ('a -> ('b * 'a) option) -> 'a -> 'b list
  val unfoldr : ('a -> ('b * 'a) option) -> 'a -> 'b list
  val reduce : ('a * 'a -> 'a) -> 'a -> 'a list -> 'a
  val appi : (int * 'a -> unit) -> 'a list -> unit
  val mapi : (int * 'a -> 'b) -> 'a list -> 'b list
  val mapPartiali : (int * 'a -> 'b option) -> 'a list -> 'b list
  val foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a list -> 'b
  val foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a list -> 'b
  val findi : (int * 'a -> bool) -> 'a list -> (int * 'a) option
  val revMap : ('a -> 'b) -> 'a list -> 'b list
  val revMapi : (int * 'a -> 'b) -> 'a list -> 'b list
  val revMapPartial : ('a -> 'b option) -> 'a list -> 'b list
  val revMapPartiali : (int * 'a -> 'b option) -> 'a list -> 'b list
  val concatMap : ('a -> 'b list) -> 'a list -> 'b list
  val concatMapi : (int * 'a -> 'b list) -> 'a list -> 'b list
  val foldMapl : ('a * 'c -> 'c) -> ('b -> 'a) -> 'c -> 'b list -> 'c
  val foldMapr : ('a * 'c -> 'c) -> ('b -> 'a) -> 'c -> 'b list -> 'c
  val splitAt : 'a list * int -> 'a list * 'a list
  val update : 'a list * int * 'a -> 'a list
  val sub : 'a list * int -> 'a
val mynth = fn : int -> 'a list -> 'a option
val x = SOME 2 : int option
#+end_example
* DONE References                                                       :LAB:

** Basics of Reference

#+BEGIN_SRC sml
val x = 10 + 2          (* value is 12 but no side effect *)
val z = print "hello\n" (* value is () but there is a side effect *)
val y = ref "hello"     (* y is bound to a new reference cell *)
val z2 = !y             (* z2 is bound to "hello" *)

(* !y is an impure expression.

  1. Side effect is to read the value associated with the reference cell y
  2. The reduced value is the value read in step 1

!y here reduces to the value "hello" and that is assigned to z2.

*)

val z1 = (y := "foo")     (* the reference cell associated with y is filled with "foo" *)
(* y := "foo" is an expression which when reduced
has the side effect of storing the value "foo" in the ref cell bound to y *)

val z3 = !y             (* z3 is bound to "foo" *)

#+END_SRC

#+RESULTS:
: hello
: val x = 12 : int
: val z = () : unit
: val y = ref "foo" : string ref
: val z2 = "hello" : string
: val z1 = () : unit
: val z3 = "foo" : string

#+BEGIN_SRC C

int main ()
{

   /* y is a reference cell capable of storing int */
   const int x = 10;
   int y z1 z2;
   y = 10;
   z1 = y;
   y  = 100;
   z2 = y;
}

#+END_SRC

** The semicolon operator.

Suppose ~e~ is the expression ~e1 ; e2~

1. What is the value associated with e
2. How does e reduce to the corresponding value.

*** Reduction of ~e~

1. First reduce ~e1~ to ~v1~ (This might not be possible because *)
2. Ignore the value ~v1~
3. Reduce ~e2~ to ~v2~

Then ~e~ gets reduced to ~v2~

#+BEGIN_EXAMPLE
e1 ----->* v1
e2 ----->* v2
e  ---->* v2

#+END_EXAMPLE

#+BEGIN_SRC sml

val x = (print "hello\n"  ; 3)
val x1 = 3

val y = ref "hello"
val z1 = ( y := "foo" ; !y )

val y1 = ref "hello"

val z2 = let val u = !y1
         in
             y1 := "foo"; u
         end

val y = ref 100
fun incrY () = (y := !y + 1; !y)


#+END_SRC

#+RESULTS:
: hello
: val x = 3 : int
: val x1 = 3 : int
: val y = <hidden-value> : string ref
: val z1 = "foo" : string
: val y1 = ref "foo" : string ref
: val z2 = "hello" : string
: val y = ref 100 : int ref
: val incrY = fn : unit -> int

Semi colon is the sequencing operation. The order
of evaluation is /important/

** Atom

#+BEGIN_SRC sml
val hello = Atom.atom "hello"
val foo   = Atom.atom "foo"

datatype expr = V of string
              | C of int
              | Plus of expr * expr
              | Mul  of expr * expr

datatype exprA = VA of Atom.atom
               | CA of int
               | PlusA of exprA * exprA
               | MulA  of exprA * exprA

fun var (str : string) = VA (Atom.atom str)

val xpone  = Plus (V "x", C 1)
val xpone' = PlusA (var "x", CA 1)
#+END_SRC

#+RESULTS:
: val hello = - : atom
: val foo = - : atom
: datatype expr
:   = C of int | Mul of expr * expr | Plus of expr * expr | V of string
: datatype exprA
:   = CA of int | MulA of exprA * exprA | PlusA of exprA * exprA | VA of atom
: val var = fn : string -> exprA
: val xpone = Plus (V "x",C 1) : expr
: val xpone' = PlusA (VA -,CA 1) : exprA


#+BEGIN_SRC sml

(* Definition of the atom structure *)

signature ATOM = sig
   .....
end

structure Atom : ATOM = struct

  (* Internal counter that keeps track of how many atoms I have allocated *)

  type atom = int
  val nvars = ref 0
  val stringToAtom = ref (* empty dictionary with key = string and value = int *)
  val atomTOString = ref (* empty dictionary with key = int value = string *)

  fun atom (x : string) = ...
  fun toString (a : atom) = ....

end



#+END_SRC
* DONE The lambda calculus                                              :LAB:

** Alonzo Church's lambda calculus


#+BEGIN_SRC sml

val incr = fn x => x + 1
fun incr1 x = x + 1

#+END_SRC

#+RESULTS:
: val incr = fn : int -> int
: val incr1 = fn : int -> int

- Function Abstraction ::
      ~fn x => x + 1~ is that function that maps ~x~ to ~x + 1~.
     ~fn x => e~ is that function that maps ~x~ to ~e~

- Function Application ::

   ~f~ is a function and ~e~ is an expression then ~f e~ is
   the application of ~f~ on ~e~



*** Church thesis (1933)

These are the only things one needs to have a full programming language.

Church used the notation ~λ x . e~ for ~fn x => e~. I.e ~λ x . e~ is that
function that takes ~x ↦ e~


** Function application.


What does it mean to say that ~fn x => e~ is that function that maps
~x~ to ~e~ ?

1. There is a notion of reduction of λ-calculus expression.

   ~(fn x => e) M -–>   e [ x := M ]~

~e [ x := M]~ . Replace ~M~ for ~x~ in ~e~

Why do I say that in SML ~F = fn x => x + 1~ is the increment function ?

~F y ≡  (fn x => x + 1) y –>  substitute y for x in x + 1.
                          –> y + 1



*** Infinite loops.

#+BEGIN_SRC

Id = fn x => x  (* is in normal form *)
A = fn x => x x
Ω = A A

Ω = (fn x => x x) A
  -> A A

#+END_SRC


** Problems with naive substitution

Variable capture.

1. ~(fn x => (fn x => x)) M~

e = (fn x => x y) ≡ fn t => t y

e [x := M]

1        1
∫ x y dx = ∫ t dt
0        0


Is ~fn x => x~ the same as ~fn t => t~


~e [x := M]~ What I mean is substitute M for every /free/ occurrance
of ~x~


** Free variables (formal definition )

The free variables of e is defined as follows.

There are three possibilities e is either

1. ~x~ in which case FV(e) = {x }

2. ~e₁ e₂~ in which case FV(e) = FV(e₁) ⋃ FV(e₂)

3. ~fn x => e'~ in which case FV (e) = FV(e') ∖ { x }


~(fn x => fn y => x)(fn t => t)~ = ~M N~  reduces to ~fn y => (fn t => t)~

where M = (fn x => fn y => x) and N = (fn t => t)

(fn x => e) L —>  e [x := L]

 In this context e is (fn y => x)




1. (fn x => fn t => x) N  –> fn t => N

  If N was fn t => t

   fn t => fn y => y


 When you substitute N for x, the context in which x occurs free should not bind any free variables
 of N.

 (fn x =>[ .....(fn t => ....x....)]) N

#+BEGIN_SRC

s0 = x00 x01 .......
s1 = x10 x11 .......
.
.
sn = xn0 xn1 ........

s
#+END_SRC


 #+BEGIN_SRC sml

val x = 10
fun foo x = fn y => x


 #+END_SRC

 #+RESULTS:
 : val x = 10 : int
 : val foo = fn : 'a -> 'b -> 'a
* DONE The λ-let and λ-letrec                                           :LAB:

let x = e in e₁  -> (fn x => e₁) e

1. The x in e₁ is the x bound in the let x = e
2. The x in e  is a free variable

let x = 5 in (let x = x + 1 in x*2)

letrec x = e in e₁ -> lambda calculus

1. F ∈ λ-calculus one can find a fixpoint X of
of F.   F X = X

1. We have a combinator Y ∈ λ-calculus such that Y F is the fixpoint
   of F for all F ∈ λ-calculus.

2.  letrec f = M(f) in e

    ===> let f = Y (λ f. M(f)) in e

 - letrec f = M (f) in e ::
Compute  the expression e where the variable f
is the solution to the recursion f = M(f)


   Let g be the fixpoint of λ f . M (f) then this expression can be written
   as let f = g in e.


   Define F = λ f . M (f))
   Let    g = Y F
          g is the fixpoint of F
          g = F g
          g = (λ f . M(f)) g
            = M (g)

   g is the solution for the recursive equation.

#+BEGIN_SRC sml
val x = let fun fact n = if n <= 0 then 1
                          else n * fact (n - 1)
        in
          fact 4
        end

#+END_SRC

#+RESULTS:
: val x = 24 : int

#+BEGIN_EXAMPLE

letrec fact = λ n . if n <= 0 then 1
                    else n * fact (n - 1)
   in fact 10


#+END_EXAMPLE


M f = λ n . if n <= 0 then 1 else n * f (n - 1)

letrec f = M (f) in e

1. Evaluate e where f is bound to the solution of
   the recursive eqn f = M f

2. Solution of the eqn f = M f is nothing but

  Y ( λ f . M (f) )

 Evaluate e in the environment where f is something
 let f = something in e

let f = Y ( λ f . M (f) ) in e

 Something is the solution to Y ( λ f . M f)

Think of M(f) as some λ-let program where f is free.


#+BEGIN_EXAMPLE

let x

#+END_EXAMPLE


letrec f1 = M(f1,f2)
       f2 = N(f1,f2)  in e

letrec (f1,f2) = ( M (f1,f2), N (f1,f2) ) = e




 Imagine you have a way to pair elements and project their component.

  pair : λ
  fst : λ
  snd : λ

  fst (pair u v) = u

  snd (pair u v) = v

  pair = (λ u . λ v . λ f . f u v)
  fst  = λ p . p K
  snd  = λ p . p K₁

  K  = λ x λ y . x  (K is the constant function )
  K₁ = λ x λ y . y  (K₁ is the ignore function )

K ignores the second argument
K₁ ignores the first argument
* TODO Higher order abstract syntax


#+BEGIN_EXAMPLE sml

(*
   <expr> = <variable>                (* variable case    *)
          | <expr>₁ <expr>₂           (* application case *)
          | λ <variable> . <expr>     (* abstraction case *)


(λ x . λ t₁ . x t₁) t₀  ->  (λ t₁ . x t₁) [x := t₀] -> λ t₁ . t₀ x
       [   M     ]  N

(λ x . M) N  =====>  M [x := N]

The above beta reduction is allowed only if FV(N) ∩ Bound(M) = ∅

Any beta reduction should not change variable binding

*)

datatype L = V  of String
           | Ap of (L, L)
           | Ab of (String, L)


#+END_EXAMPLE

SML itself is a λ-calculus.

#+BEGIN_EXAMPLE sml

datatype HL = HV  of String
            | HAp of (HL, HL)
            (* | Ab of (String, L)  *)
            | HAb of (HL -> HL)


(*
C of τ

C : τ -> Whatever is your type

*)
(*

λ x . x           Ab ("x", V "x")

                  HAb (fn e => e)
λ x y . x        Ab ("x", Ab ("y", (V "x"))

λ x . (λ y . x)
                 HAb (fn x => (HAb (fn y => x))


 A = λ f x . f (f x)

(λ x . M) N -> M [x := N]

HA (HAb f, N) = f N

f : HL -> HL


(λ x . λ t . x t y)) t

Ab ("x" , (Ab ("t", Ap (V "x", V "t)))) V "t"

 Ab ("t",  Ap (V "t", V "t"))

HAb ( fn (x : HL) =>  HAb (fn (t : HL) => HAp x  t) HV "t"



Hab : (HL -> HL) -> HL
HAb (fn (t : HL)  => (HAp (HV "t"), t)


HAb : (HL -> HL) -> HL

HV : string -> HL



*)


#+END_EXAMPLE


1. In our case the language of interest is λ-calculus (object
   language), i.e. the language we are studying/implementing.

2. Our implementation language is SML (meta-language).

3. The constructs in the object language are expressed as datatypes in
   the meta-language. (Using algebraic types to capture syntax)

4. Capture the "binding" structure in the meta-language is what HOAS
   ("Higher order abstract syntax") allows you to do. Often one needs
   to substitute terms for a bound variable (like in the case of
   β-reduction)


HOAS is used in the internal representation of the language.

1. Cannot be used to show results to user.

2. When you parse what you get is a usual representation not HOAS.


#+BEGIN_EXAMPLE sml

subst : (string * lam) -> lam -> lam

(*
subst ("x",N) e  has to do  e [x := N]

*)

fun subst (x,N) (V y)       = ...
  | subst (x,N) (A (e1,e2)) = A (subst (x,N) e1), (subst (x,N) e2))
  | subst (x,N) (L (u, e))  = ..

substH : (string * HL) -> HL -> HL
fun substH (x,N) (HV y)       = ... same as above
  | substH (x,N) (HA (e1,e2)) =  HA (substH (x,N) e1), (substH (x,N) e2))
  | substH (x,N) (HAb f)      =
           let fun fp t = subst (x,N) (f t )
           in
              HAb fp

(*

If f is (fn t => M) then fp should be

       (fn t => substH (x,N) M)

M = λ t . t x

abstract "x" M  should give me (λ x λ t . t x)

parse and get lam and then convert to the internal repsentation which is hlam

hoas : lam -> hlam

fun hoas (V x)       = HV x
  | hoas (Ap (e1,e2) = HAp (hoas e1, hoas e2)
  | hoas (L (x,e)    = ?


(* internal representation to outside world *)

fun syntax : hlam -> lam

fun syntax (HV x)          = V x
  | syntax (HAp (e1, e2)   = Ap (syntax e1, syntax e2)
  | syntax (HAb f)         = ?

(*
  Generate a fresh variable name x and then just   L (x , syntax (f (HV x) ))


HAbs f   -> Abs (u, syntax f (HV u))

f = fn t => HAp (HV "x", t)

HAp (HV "x", HV "y")

["x", "y"]

freeP M will generate a list which is a super set of the free variables of M

λ x . x x

λ u . x u

*)

*)

(* substH ("x",N) (HAb (fn t => HA (t , (HV "x"))))

 substH ("x", N) (HAb (fn t => t))

 λ t . t  [ x := N]

  HAb (fn t => N)
*)
(* f : HL -> HL *)
#+END_EXAMPLE


#+BEGIN_EXAMPLE

Y = λ f . (λ x . f (x x)) (λ x . f (x x))


#+END_EXAMPLE

#+BEGIN_SRC sml

val Y = fn f => (fn x => f ( x x ))(fn x => f (x x))

val F f = fn n => if n <= 0 then 1 else n * f (n -1)

g = Y F

(*
  = (fn f => fn x => f (x x)) (fn x => f (x x))) F
  = (fn x => F (x x)) (fn y => F (y y))
    F ((fn y => F (y y)) (fn y => F (y y))    )

*)
    F (Y F) = F g

  = fn n => if (n <= 0) then 1 else n * ((Y F) (n-1))

g is the fix point of F

g satisfies the equation g = F g

which is equivalent to

g = fn n => if n <= 0 then 1 else n * (g (n - 1))
#+END_SRC

#+RESULTS:
: stdIn:6.30-6.33 Error: operator is not a function [circularity]
:   operator: 'Z
:   in expression:
:     x x
: stdIn:6.48-6.51 Error: operator is not a function [circularity]
:   operator: 'Z
:   in expression:
* TODO Unification algorithm.

The main reason for studying Unification algo is for type inference.

#+BEGIN_SRC sml

(* Domain of map is ('a -> 'b)  and range is ( 'a list to 'b list) *)

(* The domain of map can it be 'c list -> ('c * 'c) list  for some choice of 'a and 'b *)
(* Is it possible to make 'c list -> ('c * 'c) list ≡ 'a -> 'b for some choice of 'a and 'b  ?

Unifying 'c list -> 'c * 'c list  with 'a -> 'b

Solve the eqn

    'c list -> ('c * 'c) list ≡ 'a -> 'b  symbolically.

*)

val map : ('a -> 'b) -> ('a list -> 'b list)
val f : 'c list -> ('c * 'c) list`

val map f

(*

1. Is map f well typed       (type checking problem)

2. What is the type of map f (inference problem)


*)

#+END_SRC

** Type checking and unification.

 base types are ~nat~ and ~bool~.

 - S = { nat, bool, -> , list, *  } signature.

   arity of nat = arity of bool = 0
   arity of -> is 2.
   arity of *  is 2.
   arity of list = 1.

   ~Term(S)~, this is just the mono-types in simply typed calculus.

   #+BEGIN_EXAMPLE
   nat -> boo     -> (nat, boo)

   #+END_EXAMPLE

   Suppose one wants to add the list type.

- Terms(S,V) is polymorphic types.


** Unification problem is.

Given two terms t₁ and t₂ find an assignment that will make the two terms the same.

t₁ = 'a -> 'b
t₂ = 'c list -> ('c * 'c) list

Then these terms can be unified with the assignment

'a ≡ 'c list   'b ≡ ('c * 'c) list

 t₁ = int
 t₂ = bool

** Telescopic assignment.

 It is a sequence of variable assignment

 σ = x₁ ≡ t₁ , ... , xₘ ≡ tₘ  with the following property.

- t₁ does *not* have variable x₁
- t₂ does *not* have variable x₁ and x₂
- t₃ does *not* have variable x₁, x₂ and x₃.

- tᵢ should not have variables x₁, x₂ ....xᵢ

Var(tᵢ) ∩ {x₁,...,xᵢ} = ∅



Think of the telescope σ as a substitution. Suppose t[σ] is the term obtained from t
but substituting the assignments in σ in that order.

I.e.

t[σ] = t [x₁ := t₁] [x₂ := t₂] ......[xₘ := tₘ]
t[σ] will not have x₁,....,xₘ in it


** Unification problem stated in terms of telescopes.

Given terms t₁ and t₂ compute (if possible) a telescope σ such that
 t₁[σ] = t₂[σ] This telescopic substitution σ is called a *unifier*
 for t₁ and t₂. The unification algorithm, will compute the *most
 general* unifier of two terms.


Capturing signatures in ML. a Type say symbol + a function that gives
the arity : symbol -> int.


#+BEGIN_EXAMPLE sml

signature SIG = sig
  (* the type of function symbols *)
  (* the arity function *)

  structure Ord : ORD_KEY (* with the additional constraint that the Ord.ord_key type
                             is the same as the type for functional symbols
                          *)

end (* SIG *)
signature VAR = sig
  (* a type for variables *)
  (* additional interface for the variable
     type like pretty printing can go here *)

  structure Ord : ORD_KEY (* with the additional condition
                             that it matches with the type of variable
                          *)

end

#+END_EXAMPLE


The term functor

#+BEGIN_EXAMPLE sml

functor Term (S : SIG, V : VAR) = struct

  datatype term = (* *)

  (* helper functions *)

end

#+END_EXAMPLE


#+BEGIN_EXAMPLE sml

datatype ('f, 'v) term = (* definition of terms with function symbols f and v variables *)


functor Unify (S : SIG, V : VAR) = struct

  val unify : (S.symbol, V.var) term -> (S.symbol, V.var) term -> (S.symbol, V.var) telescope

end

#+END_EXAMPLE


** Challenge of maintaining a telescope

Consider a telescope implemented via the Map data structure in SML. The
empty map is a telescope.

The challenge to solve is when is it allowed to add an equation x ≡ t to
the map.

1. Really we want to avoid the recursion when doing the substitution.

 2. We want to know whether x "occurs" in t

#+BEGIN_EXAMPLE

Current key value map is t
 x  -> f(y,z)
 y  -> g(u,v)

 u   -> h(x,x)

 u ≡ h(x,x)


#+END_EXAMPLE

 1. Find the set S₀ of variables that occurs in t
 2. For each such variable compute the assoicated term and compute the variables that occur in it.
    Sₒ ∪ that set.
 3. Keep doing this till there is no more updates.

Suppose σ is the current telescope. We can add x ≡ t into this telescope if and only if
{x} ∩ Occurs(t[σ]) = \empty set.

Occurs(t) is the set of variables that occurs in t.
