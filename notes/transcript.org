#+STARTUP: indent
* DONE Class Room 1 :: Getting started

** Basic Information

- Instructor :: Piyush <ppk@.>
- TAs

  1. Chilankamol Sunny
  2. Haritha Madhav C
  3. Lijo M Jose

- Bitbucket Repository :: https://bitbucket.org/piyush-kurur/popl

Hosting site for git repositories

- Moodle website :: https://lms.iitpkd.ac.in
- Youtube channel :: https://www.youtube.com/channel/UCfCBIg1UZAYs5rjCR9GiBow
- Google meet link :: Link already sent to you

** Format of the lectures

/Flipped classroom/ model of lectures

- There will be weekly videos that I will post at the Youtube channel
- Interactive session weekly once (Monday 11:00-12:00 hrs/9:30-10:30)
- Lab Interactive session (PoPL Lab) (Thursdays 14:00-15:30 hrs)
- TAs will have a surprise interaction with you to check you are not asleep

** Grading

- Try have a lot of Short quizes (Monday 9:00-9:30 in the Even week). Over
  moodle (best n-2 in n). best n-1 in n (60-80%)

- End sem

** TODO At Home (Homework 0)

1. All of you have a laptop/desktop with internet

2. Should have a working GNU/Linux partition (Debian/Ubuntu)

3. Basics of computing

4. Start using a good editor (Emacs)

5. Should know how to install some software.

#+BEGIN_SRC bash

sudo apt install git   # debian/ubuntu
sudo apt install mlton

#+END_SRC

** Things to learn in the process of doing this course

1. git
2. make files etc dev tools on linux

** What this course is about

- Basic principles by which programming languages are designed

  - Functional Programming (SML - Standard Meta Language)
  - Rust (Imperative programming language)
  - Logical programming (Prolog)
  - Type systems, Concurrency, Modularity - Principles behind programming
languages.

- Compilers in the next semester

- Lab component

  - Using the theory and putting it into practice.
  - Side benefits (git, general programming practices)
  - Compilers course next semester some of these things will put into practice


* DONE Class Room 2 :: Basics of Standard ML
SCHEDULED: <2020-08-10 Mon>

** The programming model for Languages

- It is a mental model of what the program /is/ and what it /does/.

- It might not be the actual implementation model. Is typically the
  machine model.

- The distinction between the programming model and the implementation
  model is important because the programming model is often
  simpler/convenient for Humans.

- Moral :: Programming Languages are both for Humans to understand and
  for machines to perform.

*** C Language

- Variables that are memory cells
- assignments that update memory cells
- There is a control flow which determines in what order the instructions are executed

** Programming model for SML

*** Variable Bindings

#+BEGIN_SRC sml

val x = 10     (* Binds the variable x to the value 10 *)
val y = 5 + 2  (* RHS = 5 + 2 (expression) ----> 7 (value)
                  Bind the value 7 to y
               *)
val z = x + y  (* RHS is not value.
                 x + y ----> 10 + y (substitution of x)
                       ----> 10 + 7 (substitution of y)
                       ----> 17
                 Binds z to 17
                 *)
val amitabbachan = "Big B"
val z1 = amitabbachan

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 7 : int
: val z = 17 : int
: val amitabbachan = "Big B" : string
: val z1 = "Big B" : string

*** Expressions

- Values are certain expressions which are no more reducible.
- Values are expressions that are in reduced form (simplified form)
- Values are defined based on the context


**** Examples

- 2     (value)
- 3 + 5 (not value) where as 8 is value
- x     (not value) but we need to figure it out from the binds applicable at the point

- "hello"



*** Computations/effects happen while expressions are evaluated.
** Hello world

#+BEGIN_SRC sml

val x = print "Hello World\n"

#+END_SRC

#+RESULTS:
: Hello World
: val x = () : unit

** Side effects and pure expressions.

#+BEGIN_SRC sml

val x = print "hello\n"  (* Prints the string "hello" as a side effect *)
val y = ()
val z = x (* No side effect as () is a value and
             hence need no reduction *)

val z = () (* This is equivalent to the above binding *)

(*

 print "hello\n" (expression)
   ----> ()

In the process there is a side effect of
printing the "hello\n"

*)

#+END_SRC

#+RESULTS:
: hello
: val x = () : unit

Certain expressions on reduction has side effects
e.g = ~print "hello\n"~ . Evaluating it has an effect on
the outside world.


Those Expressions whose evaluation  do not have side effect is
called a /pure expression/

1. ~print "hello"~ is an expression that is /not/ a value
2. It reduces to the value ~()~
3. The reduction has the side effect of printing "hello"
4. However, the resulting value ~()~ has no side effect.

*** SML is /not/ a pure functional programming language

Because there are expressions (e.g ~print "hello"~) whose reductions
have side effect.




** Unit

1. Type called ~unit~
2. It has only one value ~()~ (call this unit, void)

#+BEGIN_SRC sml
fun identity x  = x
fun hello ()   = print "hello\n"
fun hello1 x   = print "hello1\n"
val z          = hello () (* --> (1) *)
val u = identity 10
val v = identity "hello"
val u1 = hello1 42        (* --> (2) *)
val u2 = hello1 "hello"   (* --> (3) *)
val _  = hello ()
val _  = print "This is just printing without binding\n"

#+END_SRC

#+RESULTS:
#+begin_example
hello
hello1
hello1
hello
This is just printing without binding
val identity = fn : 'a -> 'a
val hello = fn : unit -> unit
val hello1 = fn : 'a -> unit
val z = () : unit
val u = 10 : int
val v = "hello" : string
val u1 = () : unit
val u2 = () : unit
#+end_example


* Information.
- Youtube play list ::
https://www.youtube.com/playlist?list=PLhMQ0_-r9W5-LeXeXQtW8UcmtdJk98hfH

- Repository ::
https://bitbucket.org/piyush-kurur/popl



* DONE Lecture 1 :: Functional Programming - Getting started
- Video :: https://www.youtube.com/watch?v=slmy8JH5Llo

Language that we will use is Standard ML (SML)

ML stands for Meta Language

** SML/NJ - New Jersey

- Interpreter
- Is quick to use
- Is good for interactive sessions
- Standalone programs can be written but not recommended.

*** Installation

#+BEGIN_SRC
sudo apt intall smlnj      # the smlnj system.
sudo apt install rlwrap    # for adding history support for sml
sudo apt install sml-mode  # for emacs
#+END_SRC

** Mlton

- Full program optimising compiler
- Is slow to use (the compilation process is slow)
- Produces standalone fast executables


*** Installation

#+BEGIN_SRC
sudo apt install mlton

#+END_SRC

*** Compiling code

#+BEGIN_SRC
mlton foo.hs # produces the foo executable
./foo        # run the executable

mlton -output myprog foo.hs # generate executable in myprog
./myprog

#+END_SRC

** Tale of two SML's
 - For interactive use smlnj
   - on terminal or in emacs

 - for standalone compiling use mlton

* DONE Lecture 2 :: Standard ML Programming model
- Video :: https://www.youtube.com/watch?v=WoVXpQkhVhw
- Video :: https://www.youtube.com/watch?v=QVxqTi8iCzw&t=5s

- The mental model of what programs are and what they do

- This need not be the way in which the language is really
  implemented.

** C programming model

- C programs have a set of variables  which are memory cells
- Assignment statements update these cells
- Programs are essentially such statements
- Computation happens by running these statements in a sequence.





** SML programming model

*** Programs are variable bindings

#+BEGIN_SRC sml
val x = 10     (* binds x to the value 10 *)
val y = x + 2  (* it evalutes x + 2 and binds it to y *)
val z = x + y

(* Binding looks like

val <variable> = expression

*)

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 12 : int
: val z = 22 : int

**** Commentary

#+BEGIN_SRC  sml
val x = 10
(*
   1. 10 is itself a value so no reduction.
   2. x gets bound to 10
*)

val y = x + 2
(*
  RHS is x + 2 -----> 10 + 2 ---> 12

  y gets bound to 12

*)
val z = x + y

(*
RHS is x + y ---> 10 + y ----> 10 + 12 ---> 22

z gets bound to 22

*)

#+END_SRC

*** Computations happen when expressions are evaluated.


1. When variables are encountered during evalution, the corresponding
   value is substituted for it and the evaluation process continues.

**** Expressions (examples)

- 2
- 3 + 100
- x
- "hello"
- print "hello"

**** Values and reductions.

A subset of expressions are designated as values and are considered
in their simplest form (normal form).

Anything that is not a value needs simplification (reduction).

#+BEGIN_SRC

3 + (10 * 2) ---->  3 + 20 ---> 23 which is value

x --> We need to look up at that point what is the value bound to x

#+END_SRC




*** SML programs are just bindings.

1. A program is a list of bindings
2. Each binding defines a variable and associates it with a value
3. The value associated to a variable is obtained by
   reducing/simplifying the RHS.
4. Computations happen while these reductions are done.

** Pure values vs evaluation with side effects.

#+BEGIN_SRC sml

val x = print "hello\n"
val y = ()
#+END_SRC

#+RESULTS:
: hello
: val x = () : unit
: val y = () : unit

1. x gets bound to the value ~()~ - unit or hermit
2. When print "hello\n" is reduced, it results in "hello" being printed
   on the terminal.
3. The value obtained in this case ~()~ does not reflect this side effect.
4. The evaluation of print "hello\n" results in a side effect of printing
   the string "hello"

In that sense print "hello" is /not/ a /pure value/

In general it is always preferable to use pure values and use
side-effects only when necessary.



* DONE Lecture 3 :: Types
- Video :: https://youtu.be/qC4RkYatlC0

** SML is a typed programming language

#+BEGIN_SRC sml
val x     = 10
val hello = "hello"
val y     = (1,"hello")
val z     = [1,2,3]
val z1    = ["hello", "world"]
(*

x : T   means x has the type T

*)
#+END_SRC

#+RESULTS:
: val x = 10 : int
: val hello = "hello" : string
: val y = (1,"hello") : int * string
: val z = [1,2,3] : int list
: val z1 = ["hello","world"] : string list

** Types rule out certain programs.


#+BEGIN_SRC  sml
val x = 2 + "hello"

#+END_SRC

#+RESULTS:
: stdIn:32.5-32.20 Error: operator and operand don't agree [overload conflict]
:   operator domain: [+ ty] * [+ ty]
:   operand:         [+ ty] * string
:   in expression:

** Types are taken seriously (strongly typed)


#+BEGIN_SRC sml

val x = 2.5
val z = 2
val y = x * 2

#+END_SRC

#+RESULTS:
: stdIn:48.5-48.14 Error: operator and operand don't agree [overload conflict]
:   operator domain: real * real
:   operand:         real * [int ty]
:   in expression:


** Strict types are great for safety

Write a program to take two numbers and compute its average.

*** In C

#+BEGIN_SRC C

# include<stdio.h>
double average( double x , double y )
{
   return 1.0/2.0 * (x + y);
}

int main ()
{
   printf("%g", average(2,3));
   return 0;
}

#+END_SRC

#+RESULTS:
: 2.5


*** In SML

#+BEGIN_SRC sml

fun average x y = 1.0/2.0 * (x + y)

#+END_SRC

#+RESULTS:
: val average = fn : real -> real -> real

* DONE Lecture 4 :: Functions
- Video :: https://youtu.be/IVeW5wv0wcA

** Definition of functions
#+BEGIN_SRC sml
fun identity x = x
fun increment x = x + 1
val z = identity 10
val helo = identity "hello"
val foo  = identity [1,2,3]
fun idInt (x : int)  = x

(*

The type of functions form A to B is A -> B
'a is a type variable.
*)
#+END_SRC
#+RESULTS:
: val identity = fn : 'a -> 'a
: val increment = fn : int -> int
: val z = 10 : int
: val helo = "hello" : string
: val foo = [1,2,3] : int list
: val idInt = fn : int -> int


- identity is a polymorphic function
- SML takes care of inferring the types of arguments and results.
- It infers the most general type possible

** Only single argument functions

- SML supports only single argument functions

- Recall :: If A and B are types then A -> B denotes the type
            of all functions from A to B

- Associativity of "->" :: It associates towards right
     ~A -> B -> C  === A -> (B -> C)~

*** Curried form

#+BEGIN_SRC sml

fun add x y = x + y

(* add takes a single argument x and returns a function that takes a single argument y
  and returns x + y
*)

val increment = add 1
#+END_SRC

#+RESULTS:
: val add = fn : int -> (int -> int)

*** Uncurried form

- A * B is the cartesian product of types A and B.
- elements of A * B are pairs (a,b) such that a : A and b : B
#+BEGIN_SRC sml

val z = (1, true)
val u = (1.0, 1, "hello")
fun add (x,y) = x + y

#+END_SRC

#+RESULTS:
: val z = (1,true) : int * bool
: val u = (1.0,1,"hello") : real * int * string
: val add = fn : int * int -> int


*** Conversion

#+BEGIN_SRC sml

(* curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c *)
fun curry f x y = f (x,y)
fun uncurry f (x,y) = f x y

#+END_SRC

#+RESULTS:
: val curry = fn : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
: val uncurry = fn : ('a -> 'b -> 'c) -> 'a * 'b -> 'c

* DONE Lab 1 :: Getting started
SCHEDULED: <2020-08-06 Thu>

** Git

1. Installation

#+BEGIN_SRC
sudo apt install git tig gitk
#+END_SRC

2. Set your name and email id.

#+BEGIN_SRC

git config --global --edit

#+END_SRC

3. Make a local repository

#+BEGIN_SRC

mkdir code/git/ROLLNO-popl -p
cd code/git/ROLLNO-popl
git init
emacs README.md
git add README.md # Asks git to keep track of changes in this file from now own
git commit -m 'added readme' # This creates a commit with message "added readme"
# or one can avoid the -m option
git commit # will open an editor


#+END_SRC

4. Have a .gitignore file

Controls what files should be ignored by git

5. I often put a pre-commit hook

This is to avoid committing changes with trailing spaces.

#+BEGIN_SRC

# Go to the top of the repository
cd ~code/git/007-popl
mv .git/hook/pre-commit.sample .git/hook/pre-commit # Enable the pre-commit hook

#+END_SRC

6. Learn more about git and you can also use magit (git operations from emacs)


** Bitbucket stuff

1. Create account on bitbucket
2. Create a new repository in bitbucket
3. Push changes from local to bitbucket repository

#+BEGIN_SRC sh

# Create a link to the remote repository on bitbucket and call it origin.
git remote origin git@bitbucket.org:piyush-kurur/007-popl.git

# Push things here to bitbucket.
git push origin -u master

#+END_SRC


** Assignment Submission Workflow

1. Give readonly access to all TA's and me (piyush-kurur) (Using the webinterface of bitbucket)

2. Write your code in the repository (within the deadline) and commit
   it.

3. Push it to bitbucket.


** Few related things to try out

1. You can fork my popl repository on bitbucket
2. You should "Watch" my popl repository
3. You can clone repositories from (say) bitbucket
4. If the repository above is your own, then you can push stuff there.

* DONE Lab 2 :: SML Tutorial.
