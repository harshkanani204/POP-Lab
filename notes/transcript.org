#+STARTUP: indent
* Class Room 1 :: Getting started

** Basic Information

- Instructor :: Piyush <ppk@.>
- TAs

  1. Chilankamol Sunny
  2. Haritha Madhav C
  3. Lijo M Jose

- Bitbucket Repository :: https://bitbucket.org/piyush-kurur/popl

Hosting site for git repositories

- Moodle website :: https://lms.iitpkd.ac.in
- Youtube channel :: https://www.youtube.com/channel/UCfCBIg1UZAYs5rjCR9GiBow
- Google meet link :: Link already sent to you

** Format of the lectures

/Flipped classroom/ model of lectures

- There will be weekly videos that I will post at the Youtube channel
- Interactive session weekly once (Monday 11:00-12:00 hrs/9:30-10:30)
- Lab Interactive session (PoPL Lab) (Thursdays 14:00-15:30 hrs)
- TAs will have a surprise interaction with you to check you are not asleep

** Grading

- Try have a lot of Short quizes (Monday 9:00-9:30 in the Even week). Over
  moodle (best n-2 in n). best n-1 in n (60-80%)

- End sem

** TODO At Home (Homework 0)

1. All of you have a laptop/desktop with internet

2. Should have a working GNU/Linux partition (Debian/Ubuntu)

3. Basics of computing

4. Start using a good editor (Emacs)

5. Should know how to install some software.

#+BEGIN_SRC bash

sudo apt install git   # debian/ubuntu
sudo apt install mlton

#+END_SRC

** Things to learn in the process of doing this course

1. git
2. make files etc dev tools on linux

** What this course is about

- Basic principles by which programming languages are designed

  - Functional Programming (SML - Standard Meta Language)
  - Rust (Imperative programming language)
  - Logical programming (Prolog)
  - Type systems, Concurrency, Modularity - Principles behind programming
languages.

- Compilers in the next semester

- Lab component

  - Using the theory and putting it into practice.
  - Side benefits (git, general programming practices)
  - Compilers course next semester some of these things will put into practice

* TODO Class Room 2 :: Basics of Standard ML
SCHEDULED: <2020-08-10 Mon>

* Lecture 1 :: Functional Programming - Getting started
- Video :: https://www.youtube.com/watch?v=slmy8JH5Llo

Language that we will use is Standard ML (SML)

ML stands for Meta Language

** SML/NJ - New Jersey

- Interpreter
- Is quick to use
- Is good for interactive sessions
- Standalone programs can be written but not recommended.

*** Installation

#+BEGIN_SRC
sudo apt intall smlnj      # the smlnj system.
sudo apt install rlwrap    # for adding history support for sml
sudo apt install sml-mode  # for emacs
#+END_SRC

** Mlton

- Full program optimising compiler
- Is slow to use (the compilation process is slow)
- Produces standalone fast executables


*** Installation

#+BEGIN_SRC
sudo apt install mlton

#+END_SRC

*** Compiling code

#+BEGIN_SRC
mlton foo.hs # produces the foo executable
./foo        # run the executable

mlton -output myprog foo.hs # generate executable in myprog
./myprog

#+END_SRC

** Tale of two SML's
 - For interactive use smlnj
   - on terminal or in emacs

 - for standalone compiling use mlton

* Lecture 2 :: Standard ML Programming model

- The mental model of what programs are and what they do

- This need not be the way in which the language is really
  implemented.

** C programming model

- C programs have a set of variables  which are memory cells
- Assignment statements update these cells
- Programs are essentially such statements
- Computation happens by running these statements in a sequence.





** SML programming model

*** Programs are variable bindings

#+BEGIN_SRC sml
val x = 10     (* binds x to the value 10 *)
val y = x + 2  (* it evalutes x + 2 and binds it to y *)
val z = x + y

(* Binding looks like

val <variable> = expression

*)

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 12 : int
: val z = 22 : int

**** Commentary

#+BEGIN_SRC  sml
val x = 10
(*
   1. 10 is itself a value so no reduction.
   2. x gets bound to 10
*)

val y = x + 2
(*
  RHS is x + 2 -----> 10 + 2 ---> 12

  y gets bound to 12

*)
val z = x + y

(*
RHS is x + y ---> 10 + y ----> 10 + 12 ---> 22

z gets bound to 22

*)

#+END_SRC

*** Computations happen when expressions are evaluated.


1. When variables are encountered during evalution, the corresponding
   value is substituted for it and the evaluation process continues.

**** Expressions (examples)

- 2
- 3 + 100
- x
- "hello"
- print "hello"

**** Values and reductions.

A subset of expressions are designated as values and are considered
in their simplest form (normal form).

Anything that is not a value needs simplification (reduction).

#+BEGIN_SRC

3 + (10 * 2) ---->  3 + 20 ---> 23 which is value

x --> We need to look up at that point what is the value bound to x

#+END_SRC




*** SML programs are just bindings.

1. A program is a list of bindings
2. Each binding defines a variable and associates it with a value
3. The value associated to a variable is obtained by
   reducing/simplifying the RHS.
4. Computations happen while these reductions are done.

** Pure values vs evaluation with side effects.

#+BEGIN_SRC sml

val x = print "hello\n"
val y = ()
#+END_SRC

#+RESULTS:
: hello
: val x = () : unit
: val y = () : unit

1. x gets bound to the value ~()~ - unit or hermit
2. When print "hello\n" is reduced, it results in "hello" being printed
   on the terminal.
3. The value obtained in this case ~()~ does not reflect this side effect.
4. The evaluation of print "hello\n" results in a side effect of printing
   the string "hello"

In that sense print "hello" is /not/ a /pure value/

In general it is always preferable to use pure values and use
side-effects only when necessary.

* Lab 1 :: Getting started
SCHEDULED: <2020-08-06 Thu>

** Git

1. Installation

#+BEGIN_SRC
sudo apt install git tig gitk
#+END_SRC

2. Set your name and email id.

#+BEGIN_SRC

git config --global --edit

#+END_SRC

3. Make a local repository

#+BEGIN_SRC

mkdir code/git/ROLLNO-popl -p
cd code/git/ROLLNO-popl
git init
emacs README.md
git add README.md # Asks git to keep track of changes in this file from now own
git commit -m 'added readme' # This creates a commit with message "added readme"
# or one can avoid the -m option
git commit # will open an editor


#+END_SRC

4. Have a .gitignore file

Controls what files should be ignored by git

5. I often put a pre-commit hook

This is to avoid committing changes with trailing spaces.

#+BEGIN_SRC

# Go to the top of the repository
cd ~code/git/007-popl
mv .git/hook/pre-commit.sample .git/hook/pre-commit # Enable the pre-commit hook

#+END_SRC

6. Learn more about git and you can also use magit (git operations from emacs)


** Bitbucket stuff

1. Create account on bitbucket
2. Create a new repository in bitbucket
3. Push changes from local to bitbucket repository

#+BEGIN_SRC sh

# Create a link to the remote repository on bitbucket and call it origin.
git remote origin git@bitbucket.org:piyush-kurur/007-popl.git

# Push things here to bitbucket.
git push origin -u master

#+END_SRC


** Assignment Submission Workflow

1. Give readonly access to all TA's and me (piyush-kurur) (Using the webinterface of bitbucket)

2. Write your code in the repository (within the deadline) and commit
   it.

3. Push it to bitbucket.


** Few related things to try out

1. You can fork my popl repository on bitbucket
2. You should "Watch" my popl repository
3. You can clone repositories from (say) bitbucket
4. If the repository above is your own, then you can push stuff there.
