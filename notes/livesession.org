#+STARTUP: indent
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
* TODO Getting started                                            :CLASSROOM:

** Basic Information

- Instructor :: Piyush <ppk@.>
- TAs

  1. Lijo M Jose
  2. Julin Shaji

- Repository :: https://gitlab.com/piyush-kurur/popl

Hosting site for git repositories

- Moodle website :: https://lms.iitpkd.ac.in
- Youtube channel :: https://www.youtube.com/channel/UCfCBIg1UZAYs5rjCR9GiBow
- Google meet link :: Link already sent to you

** Format of the lectures

/Flipped classroom/ model of lectures

- There will be weekly videos that I will post at the Youtube channel
- Interactive session weekly once (Monday 10:00-11:00 hrs
- Lab Interactive session (PoPL Lab) (Monday 14:00-midnight hrs)
- TAs will have a surprise interaction with you to check you are not asleep

** Grading

- Try have a lot of Short quizes (Consult the quiz schedule). Over
  moodle (best n of n+1).  (60-80%)

- End sem

** TODO At Home (Homework 0)

1. All of you have a laptop/desktop with internet

2. Should have a working GNU/Linux partition (Debian/Ubuntu)

3. Basics of computing

4. Start using a good editor (Emacs)

5. Should know how to install some software.

#+BEGIN_SRC bash

sudo apt install git   # debian/ubuntu
sudo apt install mlton

#+END_SRC

** Things to learn in the process of doing this course

1. git
2. make files etc dev tools on linux

** What this course is about

- Basic principles by which programming languages are designed

  - Functional Programming (SML - Standard Meta Language)
  - Rust (Imperative programming language)
  - Logical programming (Prolog)
  - Type systems, Concurrency, Modularity - Principles behind programming
languages.

- Compilers in the next semester

- Lab component

  - Using the theory and putting it into practice.
  - Side benefits (git, general programming practices)
  - Compilers course next semester some of these things will put into practice


* Functional Programming
SCHEDULED: <2021-08-23 Mon>

**  Why SML?

Functional programming through Standard ML (SML)

- ML :: means meta-language.

- History is the implementation of a LCF proof assistant.

  LCF  is the object language and ML was  designed to be the
  meta language for LCF.

- SML :: is probably the only programming language which has a /formal
  semantics/ (meaning).

  1. Syntax :: Grammar of the language.

  2. Semantics :: Meaning of the language. There is a formal semantics
     of SML that has been checked through a proof assistant.

     SML is "type safe"

  3. LCF system's correctness depends on SML's type safety and hence type safety of
     SML was very important.

     For each of the theorems you create a "proof object" and if SML was type unsafe you
     can create "wrong proofs".

  4. As a language it is really simple but some deep concepts are
     available. SML has a concurrency mode (Concurrent ML which is
     really advanced).

  5. Introduces to a lot of programming language concepts.

     1. Type systems
     2. Continuations CPS system
     3. Module systems.

#+begin_src C

  int main()
  { int c=42;
    char *hello = "hello";
    double x y ;

    double av = 1/2 * (x + y); // ill typed expression
    printf("%s %d %p", c , hello, c + hello);
    hello[c]= 0;
    return 1;
  }
#+end_src

- Type safety :: If the compiler says that your program has not "type mismatch", there
should not be a illegal instruction executed during the run of the program.

- Type Unsafe languages :: There are programs where the compiler will not flag a "type mismatch"
  but will lead to a "Stuck" state.



Accessing ~hello[i]~ can result in undefined behaviour.






** Two SML compilers/interpreters.

*** Two phases of development of an application

- Development phase ::

  + What is important ?

    1. Speed of compilation
    2. Quick feedback
    3. Quickly checking out a piece of code (prototyping)
    4. Better error messages when things are not okey.

  + What you do not care about

    1. Speed of the resulting executable
    2. Space taken by the resulting code.
    3. You do not care about efficiency of execution.


- Deployment phase ::

  + What you care about is efficiency of the executable and not the feedback to the developer.


*** SML/NJ - New Jersey SML interpreter

smlnj should be used in the development phase

smlnj can be used to build a standalone executable but it is not
recommended.

*** Mlton - Compiler for SML

mlton compiler should be used in the production phase.
mlton is a compiler and not an interpreter.
* Basics of Standard ML                                           :CLASSROOM:
SCHEDULED: <2020-08-10 Mon>

* Programming model for SML
SCHEDULED: <2021-08-30 Mon>

There are two views to the programming language.

1. The view of the programmer ::

   The things of interest are the high level info of what the given
   program does.

   The programmer needs to think of how to accompish the programming
   task at hand using high level programming concepts.

   1. How do I break the big task into smaller task ?

   2. Can I generalise certain programming patterns and refactor them into
      functions ?

   3. Can I use already existing library ?

   4. What should I do so that I make less errors ?

   5. Is the following code understandable to others ?

2. The view of the implementer.

   The things of interest are those that guide efficient implementation
   of the "programmer"s view.

   1. Is it possible to vectorise certain code ?

      a = a + c
      ap = ap + cp

      [a, ap] = [a , ap] + [c,cp]

   2. Can a certain recursive code be converted to loops ?

   3. Which variables need to be in registers at what point of time ?


3. If you are working on Computer Arch, then the assembly language itself
   is a "programmers view" ?



** The programming model for Languages

- It is a mental model of what the program /is/ and what it /does/.

- It might not be the actual implementation model which is typically
  the machine model.

- The distinction between the programming model and the implementation
  model is important because the programming model is often
  simpler/convenient for Humans.

- Moral :: Programming Languages are both for Humans to understand and
  for machines to perform.

*** C Language

- Variables that are memory cells
- assignments that update memory cells
- There is a control flow which determines in what order the instructions are executed

** Programming model for SML

*** Variable Bindings

- Variables :: x y z etc
- Expressions/terms :: 10 , 5 + 2, can be a variable
- Values :: are expressions that are in their "simplest" form.
- Environment :: is a function from Variables to values.

When an expression is a value ?

Values ⊆ Expressions

The programming model for sml is the following :


1. The program consists of a sequence of /variable bindings/.

2. A variable binding looks like ~val <variable> = <expr>~

3. A subset of expressions are called /Values/. These are
   those expressions that are in the simplest form.

4. The SML language when it encounters a binding ~val x = e~,
   evaluates (tries to) the Right Hand Side e of the binding (which is
   an expression) to its simplified form (which is a value) ~v~. And
   then it updates the /environment/ by binding the variable to ~x~ to
   ~v~. At this point of "time" we say that the variable x is /bound/
   to the value v.





#+BEGIN_SRC sml

   (* Environment is stdlib + {}*)
   val x = 10     (* Binds the variable x to the value 10 *)

   (* Environment becomes stdlib + {x = 10} *)

   val y = 5 + 2  (* RHS = 5 + 2 (expression) ----> 7 (value)
                       Bind the value 7 to y
                  ,*)
    (* Env = stlib + { x =10 ; y = 7 }  *)


   val z = x + y  (* RHS is not value.
                      x + y ----> 10 + y (substitution of x)
                            ----> 10 + 7 (substitution of y)
                            ----> 17
                      Binds z to 17
                      ,*)

  (* Env = stdlib + {x = 10 ; y = 7; z = 17 *)

   val amitabbachan = "Big B"

   val z1 = amitabbachan
   (* Env = ? *)

#+END_SRC

#+RESULTS:
: val x = 10 : int
: val y = 7 : int
: val z = 17 : int
: val amitabbachan = "Big B" : string
: val z1 = "Big B" : string

*** Expressions

- Values are certain expressions which are no more reducible.
- Values are expressions that are in reduced form (simplified form)
- Values are defined based on the context


**** Examples

- 2     (value)
- 3 + 5 (not value) where as 8 is value
- x     (not value) but we need to figure it out from the binds applicable at the point

- "hello"



*** Computations/effects happen while expressions are evaluated.
** Hello world

#+BEGIN_SRC sml

val x = print "Hello World\n"

#+END_SRC

#+RESULTS:
: Hello World
: val x = () : unit

** Side effects and pure expressions.

#+BEGIN_SRC sml

val x = print "hello\n"  (* Prints the string "hello" as a side effect *)
val y = ()
val z = x (* No side effect as () is a value and
             hence need no reduction *)

val z = () (* This is equivalent to the above binding *)

(*

 print "hello\n" (expression)
   ----> ()

In the process there is a side effect of
printing the "hello\n"

*)

#+END_SRC

#+RESULTS:
: hello
: val x = () : unit

Certain expressions on reduction has side effects
e.g = ~print "hello\n"~ . Evaluating it has an effect on
the outside world.


Those Expressions whose evaluation  do not have side effect is
called a /pure expression/

1. ~print "hello"~ is an expression that is /not/ a value
2. It reduces to the value ~()~
3. The reduction has the side effect of printing "hello"
4. However, the resulting value ~()~ has no side effect.


An expression ~e~ which reduces to a value ~v~ is said to be /pure/
if every binding of the form ~val x = e~ can be replaced by the binding
~val x = v~ without changing the behaviour of the program.

Any expression that does not have the above property is said to have
"side-effects".

*** SML is /not/ a pure functional programming language

Because there are expressions (e.g ~print "hello"~) whose reductions
have side effect.




** Unit

1. Type called ~unit~
2. It has only one value ~()~ (call this unit, void)

#+BEGIN_SRC sml
fun identity x  = x
fun hello ()   = print "hello\n"
fun hello1 x   = print "hello1\n"
val z          = hello () (* --> (1) *)
val u = identity 10
val v = identity "hello"
val u1 = hello1 42        (* --> (2) *)
val u2 = hello1 "hello"   (* --> (3) *)
val _  = hello ()
val _  = print "This is just printing without binding\n"

#+END_SRC

#+RESULTS:
#+begin_example
hello
hello1
hello1
hello
This is just printing without binding
val identity = fn : 'a -> 'a
val hello = fn : unit -> unit
val hello1 = fn : 'a -> unit
val z = () : unit
val u = 10 : int
val v = "hello" : string
val u1 = () : unit
val u2 = () : unit
#+end_example





* Polymorphism (Parametric)

** Recap

#+begin_src sml
  val x : int = 10     (* binds x to 10 *)
  fun f x = x + 1	   (* can also be recusive,
                              binds f to the function that takes x and returns x +1 *)

  fun g (x : int) = x + 1
#+end_src

- Strong typing :: Every expression in SML has a type and the compiler
  enforces type checking at compile time.

- Type inference :: When ever an expression can be given a valid type, the compiler
  infers the type (it infers the /most general type/).

- Parametric polymorphism :: A function can work with different types.
  poly-morphism morphism is another word for function and poly morphism means multiple
  possible functions.

  You can think of ident as a /family/ of functions one for each possible instantiation of
  'a with types.

  Note that SML does type checking at compile time unlike say Python. But the combination of
  Type inference + Parametric polymorphism make it look like you do not have to worry about
  declaring the types.

 - Adhoc polymorphism or Overloading ::  C++ without template. Java without generics
   provide a way to give same name to different functions. The actual function that is
   used /depends on the type/

   E.g overloading of + or << in C++   << is bitwise left shift as well as cout << "hello"

   (1) << takes two ints then it should be the left shift of Int
   (2) if it is a ostream and the right operator is string then it is a printing function

  - SML does not have overloading but there are other ways for it.

#+begin_src sml
  fun ident x = x   (* int -> int, or string -> string,  (int -> string) -> (int -> string) *)
  fun idInt (x : int) = x
  fun curry f x y = f (x,y)
#+end_src

SML infers the type ~'a -> 'a~ here ~'a~ is a type variable


What type really are ?

1. Types are specifications to your value.

2. As a client hiring you for writing code, I have to give you my requirements (or Specs)
   It is your job to write the code for it.

   'a -> 'a

- Moral of the story :: whenever possible write the most general function.

Map function. It takes a function f and a list l and gives the list
obtained by applying f on every element of the list.


~map : ('a -> 'b) -> 'a list -> 'b list~

Let g be any function that has the above polymorphic type. g has to
apply f on the list, drop or duplicate the elements of the list, and
rearrange in some specific way












* Pattern matching

#+begin_src sml
   val x = 10      (* an equantion that says in this context x is 10 *)
   fun f x = x+1   (* we say f is that function that satisfies f x = x + 1 *)
   fun konst _ = 10
   fun first (x, _) = x (* I have used variable pattern, wild card and tuple pattern *)

   fun foo ( _ , _ , y) = y + 1


   (*
      fun foo p = ... where p is the pattern (p₁, p₂)  p: 'a * b where p₁ : 'a, p₂ : 'b
                            p₁ is the pattern (p₁₁, p₁₂)  'a = 'a₁ * 'a₂
                            p₁₁ and p₁₂ are both _

                            p₂ is the pattern y : 'b , 'b has to be int because RHS has y + 1
                              RHS type is 'c so 'c and 'b has to be type int

     foo : ('a₁ * 'a₂) * int -> int

     foo : A * B -> C  where A = 'a₁ * 'a₂

     foo : A * B * C -> D
  ,*)

   fun bar (   _   , y) = y + 1

   (* length : 'a list -> int *)
   (* fun length (xs : 'a list) = ... : int *)
   fun length []        = 0
     | length (_ :: ps) = 1 + length ps

   (* map f [x₁,....,xₙ] = [ f x₁ , f x₂ , .... , f xₙ ]

      map : 'a ->           'b           -> 'c
      map : ('a₁ -> 'a₂) -> 'b₁ list     ->'c₁ list
      map : ('a₁ -> 'a₂) -> 'a₁ list     -> 'a₂ list
      map : ('a -> 'b) -> 'a list -> 'b list

    ,*)
   (* fun map f xs = ....  *)
   fun map f (p :: ps) = f p :: map f ps
     | map _ []        = []

#+end_src

#+RESULTS:
: val x = 10 : int
: val f = fn : int -> int
: val konst = fn : 'a -> int
: val first = fn : 'a * 'b -> 'a
: val foo = fn : 'a * 'b * int -> int
: val bar = fn : 'a * int -> int

Patterns

We define what are patterns. A pattern on the LHS servers two purposes In an equation
like ~fun f p = e~ , p restrict the allowed values to certain forms and also leads
to variable binding. We call this process "pattern matching"




1. A variable :: A variable pattern ~x~ matches any value (of appropriate type) and binds
   x to it for use in RHS

2. A wild card  i.e ~_~.  The wild card patter ~_~ matches any value but that value is not
   available as binding on the RHS. One uses a wild card when one does not care about the value.

** Tuples

What is the type ~A * B~ ? To answer that question I have to give you
what are the elements of the type ~A* B~. Or in other words what are
the values ~v~ such that ~v : A * B~ ?

- Construct :: Let v₁ : A and v₂ : B be values of type A and B respectively then
   (v₁ , v₂) is a value and is of type ~A * B~

- Take apart ::  If ~v : A * B~ is a value then there is ~v₁ : A~ and ~v₂ : B~  such that
   ~v = (v₁ , v₂)~

   Which means if you want to write a function f: A*B -> C then what you need to specify
   what the function value is on a tuple (v₁, v₂) where v₁ : A and v₂ : B.


*** Tuple Pattern

If p₁ and p₂ are patterns then (p₁ , p₂) is also a pattern.

When you use the tuple pattern : The match is successful if and only if the value
is of the form (v₁, v₂) where p₁ matches v₁ and p₂ matches v₂

*** Generalising to n-tuples for any n ∈ ℕ

If A₁ .... Aₙ are types then the type A₁ * ... * Aₙ consists of values

- Construction :: If v₁ : A₁ .... vₙ : Aₙ then (v₁,....vₙ) : A₁ * ... * Aₙ
- Taking apart :: The only possible values of the n-tuple type A₁ * ... * Aₙ
  is the one obtained by applying the construction rule

  The pattern for n-tuple would be

  (p₁,...,pₙ) where pᵢ is a pattern of type Aᵢ


** Lists

What is a ~'a list~ ? Again I need to tell you what the elements of this type are.


- Construction ::

  1. The empty list ~[]~ is a /value/ of type ~'a list~.
  2. If ~v : 'a~ and ~vs : 'a list~ then ~v :: vs : 'a list~ where ~v~ and ~vs~ are values

- Taking apart :: The only possible values of type ~'a list~ are the ones created out of
  the above two rules.

This types that are defined by a set of finite rules together with the appropriate Taking apart
condition

The taking apart condition is the rule that says that the type is the "smallest" type with
the Construction rules.

*** List patterns.

1. [] is a list pattern that matches an empty list of type 'a list

2. If ~p~ and ~ps~ are patterns of types ~'a~ and ~'a list~ respectively then
   ~p :: ps~ is a pattern of type ~'a list~.

   p :: ps  matches a list v :: vs where p match v and ps matches vs

   The bindings created are the bindings that is the result of matching p to v
   and ps to vs.

   #+begin_example sml
     fun g x = x + 1
     fun f (g y) = y - 1 (* Not Allowed *)

                      (* Check if the value given to f as argument looks like g y for some y *)
		            (* Then bind y to that value *)


   #+end_example
*  Old notes starts here


* DONE Types and Functions                                        :CLASSROOM:
SCHEDULED: <2020-08-17 Mon>

** Standard ML has types

It is strongly enforced.


|                       | Weak types | strong types |
|-----------------------+------------+--------------|
| Static type checking  | C, C++     | SML, Java    |
| Dynamic type checking | JavaScript | Ruby, scheme |


*** Static type checking

- Advantages ::

1. Errors are caught before deployment.
2. More efficient code is expected out of static type checking

- Disadvantages ::

1. Very verbose type declarations.
2. Not easy to prototype

These complaints are because of languages like Java.

SML has this nice property that it can infer the types.

#+BEGIN_SRC sml

fun add x y = x + y

#+END_SRC

#+RESULTS:
: val add = fn : int -> int -> int

** Strong types are good

Write a function to compute the average of two real numbers.

#+BEGIN_SRC C
# include <stdio.h>
double av( double x , double y)
{
   return 1/2 * (x + y);
}

int main ()
{
   printf("the result is %g\n", av(2,3));
}


#+END_SRC

#+RESULTS:
: the result is 0

The bug is due to the automatic conversion from
integers to double.

#+BEGIN_SRC sml

fun av x y = 1.0/2.0 * (x + y)


#+END_SRC

#+RESULTS:
: val av = fn : real -> real -> real



** What are types

- Basic types :: ~int~, ~bool~, ~char~, ~string~

#+BEGIN_SRC sml
val anInt = 10
val aBool = true
val anotherBool = false
val aChar = #"c"
val aString = "hello\n"

#+END_SRC

- Compound types :: product types, lists etc

#+BEGIN_SRC sml
val y = (1, "hello")
val y1 = (1,true, "hello")
val x  = #1 y
val h =  #2 y
val z = [1,2,3]
val z1 = [ "hello", "world"]
val u = 2 :: z
val u1 = []
val u2 = "foo" :: z1
fun bar x (y : real) = x + y
fun bar1 x y = (x+1,y)

(*
 A * B  is the type of all tuples (a,b) where a : A and b : B.

'a , 'b , 'c  --> type variables

A -> B denotes the type of functions from A to B

Functions whose range is B and domain is A

*)
#+END_SRC

#+RESULTS:
#+begin_example
val y = (1,"hello") : int * string
val y1 = (1,true,"hello") : int * bool * string
val x = 1 : int
val h = "hello" : string
val z = [1,2,3] : int list
val z1 = ["hello","world"] : string list
val u = [2,1,2,3] : int list
val u1 = [] : 'a list
val u2 = ["foo","hello","world"] : string list
val bar = fn : real -> real -> real
val bar1 = fn : int -> 'a -> int * 'a
#+end_example



- Polymorphism :: SML figures out the most general possible type.
This kind of polymorphism is called parametric polymorphism


** Function evaluation

*** Variable bindings
*** Reductions/simplifications

#+BEGIN_SRC sml

fun increment x = x + 1
(* the variable increment is bound to that function which on input x gives x + 1 *)
val x = 10
val z = increment (2 + x)

fun foo (x,y) = x + y

fun bar () () = ()

val u = bar (print "hello\n")


(*
    f            e
    increment (2 + x) ---> increment (2 + x)
                     ---> increment (2 + 10)
                     ---> increment 12 ----> bind x to 12 and evalute (x + 1 )
                     ---> 12 + 1
                     ---> 13
                       match it with the lhs (identity x) which binds x to 12
    (1) reduce f
    (2) reduce e
    (3)

Eger evaluation: Arugments are reduced before functions are applied.
lazy evaluation: Arugments are evaluated only when needed.

*)

#+END_SRC

#+RESULTS:
: hello
: val increment = fn : int -> int
: val x = 10 : int
: val z = 13 : int
: val foo = fn : int * int -> int
: val bar = fn : unit -> unit -> unit
: val u = fn : unit -> unit

1. First the RHS is reduced to a value and then
   bound to x

2. During evaluation if a variable is found then
   its corresponding bound value is substituted

* DONE Algebraic data types and Pattern Matching                  :CLASSROOM:
SCHEDULED: <2020-08-24 Mon>

** More types

1. Types i.e basic types like ~int~, ~real~, ~string~
2. Cartesian produce ~int * real~
3. Function types ~int -> string~
4. Polymorphism ~'a -> 'b -> 'a~
5. Type aliasing

#+BEGIN_SRC sml

type complex = real * real
val x : complex = (2.0, 1.0)

fun realpart (a:real, b:real) = a
val z = realpart x
(*
 complex is just a new name for real * real.
As types they are the same.

*)
#+END_SRC

#+RESULTS:
: type complex = real * real
: val x = (2.0,1.0) : complex
: val realpart = fn : real * real -> real
: val z = 2.0 : real

** Algebraic type.

#+BEGIN_SRC sml

datatype Day = Sun
             | Mon
             | Tue
             | Wed
             | Thu
             | Fri
             | Sat

(* If SML did not have booleans *)
datatype Bool = True
              | False

(* how to define a value of type Day *)
val x = Sun

(* how to write functions *)

(*

Write a function isHoliday : Day -> bool

1. d : Day
2. ... : bool

*)
fun isHoliday Sun = true
  | isHoliday Sat = true
  | isHoliday _   = false


(*


isHoliday Mon  ---->
  Try in this order

  1. match isHoliday Sun with isHoliday Mon ---> true
  2. match isHoliday Sat with isHoliday Mon ---> true
  3. match isHolida  _   with isHoliday Mon ---> false


*)
(*

This is not like enum of C or C++ because
there is not automatic conversion from enum
to int and vice-versa

*)

#+END_SRC

#+RESULTS:
: stdIn:107.5-107.25 Warning: match nonexhaustive
:           Sun => ...
:
: datatype Day = Fri | Mon | Sat | Sun | Thu | Tue | Wed
: datatype Bool = False | True
: val x = Sun : Day
: val isHoliday = fn : Day -> bool

#+BEGIN_SRC sml

val x = SOME 10
val y = NONE

(*

head is a function that takes a list and
produces the first element of the list.

head : 'a list -> 'a

head is not defined on empty list
THis will be a runtime bug because

head e

headSafe : 'a list -> 'a option


datatype 'a option = SOME of 'a
                   | NONE


print : string -> ()

*)

datatype 'a Option = Some of 'a
                   | None

fun head (x :: _) = x

fun headSafe (x :: _) = SOME x
  | headSafe _        = NONE


val foo = head [1,2,3]
val bar = headSafe []
val _   = print (head ["foo" , "bar" ])
val _   = print (head [])

val _   = print (headSafe ["foo", "bar"])
#+END_SRC

#+RESULTS:
: stdIn:233.5-233.22 Warning: type vars not generalized because of
:    value restriction are instantiated to dummy types (X1,X2,...)
: stdIn:237.5-237.42 Error: operator and operand don't agree [tycon mismatch]
:   operator domain: string
:   operand:         string option
:   in expression:

#+BEGIN_SRC C

int main ()
{
  FILE *fp;
  if ( fp = fopen("hello"))  == NULL)
  {
     /*
      handle the fact that there is no hello file */
  }
  ... stuff with fp

}

#+END_SRC
* DONE Abstract syntax and datatypes                              :CLASSROOM:
SCHEDULED: <2020-09-05 Sat>

** While writing compilers

1. Captures the constructs of the language

2. Depending on the construct translate the code to target code

3. Use the constructs of the language to (in an editor) highlight parts
   differently

4. Source code processing like indenting, linting,


Keeping the programs text is not very convenient.


1. Some syntax is just sugar
   e.g [1,2,3] is a sugar for 1 :: 2 :: 3 :: []

2. Program text needs to worry about things like precedence whereas
   the representation that we see need not worry.

** Abstract syntax of the language

This is a term used mainly in programming language theory.

- Parse tree  - compiler literature
- Abstract syntax tree

Consider the language of expressions with + and * and constants (integers)

#+BEGIN_EXAMPLE
1 + 2 * 3

(1 * 2) + 3

(1 + 2) * 3

1 +   -- not an expression
1 3   -- not an expression

(1 + 2) 3 -- not an expression

#+END_EXAMPLE

- Concrete syntax ::

1. Governs what string/text is valid program
2. We want to know "how" the string is a member of the language. x ∈ L
3. We need ways to ensure that the grammar is unambiguous
4. Used to convert from "textual" representation of
   the program to .... abstract syntax or parse trees


#+BEGIN_EXAMPLE

E -> nat    -- nat rule
  |  E + E  -- plus rule
  |  E * E  -- mul rule   has more precedence
  | ( E )   -- paren rule


Proof that 1 + 2 * 3 is an E  --- 1 + {2 * 3}

(1) 1 is an E  (nat rule)
(2) 2 is an E  (nat rule)
(3) 3 is an E  (nat rule)
(4) 2 * 3 is an E (mul using 2,3)
(5) 1 + 2 * 3 is an E (plus using 1,4)


Proof that 1 + 2 * 3 is an E   {1 + 2} * 3

(1) 1 is an E  (nat rule)
(2) 2 is an E  (nat rule)
(3) 3 is an E  (nat rule)
(4) 1 + 2 is an E (plus using 1,2)
(5) 1 + 2 * 3 is an E (mul using 3,4)

#+END_EXAMPLE


Expressing expressions as trees will not have a problem of ambiguity.

#+BEGIN_EXAMPLE

         1 + {2 * 3}          {1 + 2} * 3

             +		           *
            / \		          / \
           1   * 		       	 +   3
              / \		      	/ \
             2   3	               1   2


#+END_EXAMPLE


- Abstract syntax ::

#+BEGIN_EXAMPLE

E -> nat
   | E + E
   | E * E

#+END_EXAMPLE

1. A nat is an expression

2. If E1 and E2 are expressions then E1 + E2 is an expression

3. If E1 and E2 are expressions then E1 * E2 is expression

#+BEGIN_SRC sml
datatype expr = Const of int
              | Plus  of expr * expr
              | Mul   of expr * expr


fun exprDenote (Const x)      = x
  | exprDenote (Plus (e1,e2)) = exprDenote e1 + exprDenote e2
  | exprDenote (Mul (e1,e2))  = exprDenote e1 * exprDenote e2

(* instruction of a stack machine *)
datatype inst = push of int
              | plus
              | mul


(*

push x :  pushes x on top of the stack

plus : x1 = pop x2 = pop ; push (x1 + x2)

mul  : x1 = pop x2 = pop ; push (x1 * x2)


*)
type executable = inst list

type stack = int list

(* instDenote : inst -> stack -> stack *)
fun instDenote (push x) stk                 = x :: stk
  | instDenote plus     (x1 :: x2 :: stk)   = x1 + x2 :: stk
  | instDenote mul      (x1 :: x2 :: stk)   = x1 * x2 :: stk

fun interp prog stk = fold....

(* compile : expr -> executable *)
fun compile (Const x)       = [push x]
  | compile (Plus (e1,e2))  = let val prog1 = compile e1
                                  val prog2 = compile e2
                              in
                                 prog2 @ prog1 @ [plus]
                              end

  | compile (Mul  (e1,e2))  = let val prog1 = compile e1
                                  val prog2 = compile e2
                              in
                                 prog2 @ prog1 @ [mul]
                              end

val one = Const 1
val two = Const 2
val three = Const 3
val x = Plus (Plus (one, two), three)
val p1 = compile x
#+END_SRC

#+RESULTS:
: datatype expr = Const of int | Mul of expr * expr | Plus of expr * expr
: datatype inst = mul | plus | push of int
: type executable = inst list
: val compile = fn : expr -> inst list
: val one = Const 1 : expr
: val two = Const 2 : expr
: val three = Const 3 : expr
: val x = Plus (Plus (Const #,Const #),Const 3) : expr
: val p1 = [push 3,push 2,push 1,plus,plus] : inst list

Abstract syntax

1. Only captures the essence of the syntax
2. Brackets and other disambiguation things can be removed.


#+BEGIN_EXAMPLE

S -> nat
  |  nat , S

#+END_EXAMPLE

#+BEGIN_SRC sml

type commaSepNat = int list

#+END_SRC
* DONE Structures and functors                                    :CLASSROOM:

** Main Idea

Main idea :: Control the name-space of definitions.

1. Possibly multiple instances of name vs value binding

2. Together with functor it gives powerful way of manipulating name space.
#+BEGIN_SRC sml

val x = 10
val x = "hello"

structure A = struct
   val  x   = 10
   type foo = int
end
(*

Modules in ocaml.

*)

val y = A.x
fun myfun (x : A.foo) = x + 1

open A (* generaly discouraged *)
fun myanotherfun (x : foo) = x + 1

val u = List.map myfun [1,2,3]

#+END_SRC

#+RESULTS:
#+begin_example
val x = <hidden-value> : int
val x = <hidden-value> : string
structure A :
  sig
    val x : int
    type foo = int
  end
val y = 10 : int
val myfun = fn : foo -> int
opening A
  val x : int
  type foo = int
val myanotherfun = fn : foo -> int
val u = [2,3,4] : int list
#+end_example

Caution

1. Do not confuse this with structures in C. In C structs are just
   product types which in SML is called records.

2. Similar to namespace in C++

** Signatures


1. Signatures can used to control what is exposed from a structure.

2. Signatures itself can be defined and used

3. Signature is used in functors to control what structures are expected to have.


#+BEGIN_SRC sml

signature MYSIG = sig
   type foo
   val  x : foo
 end

structure A : MYSIG

(* sig
   val x : int
   type foo
  end *) =  struct

val x = 10
val y = 100
type foo = int
type bar = string
end

val y = A.x  (* this is fine *)
(* val z = A.y  (* not fine as y is not exposed *) *)


structure B : MYSIG = struct

  type foo = string
  val x    = "hello"

end

#+END_SRC

#+RESULTS:
: signature MYSIG =
:   sig
:     type foo
:     val x : foo
:   end
: structure A : MYSIG
: val y = 10 : foo
: structure B : MYSIG


** An analogy with values and types


| Value world            | Structure world                  | Ocaml        |
|------------------------+----------------------------------+--------------|
| values (val)           | structures (structure .. struct) | module       |
| types  (type/datatype) | signatures (signature .. sig)    | module types |
| functions (fun)        | functor                          | functor      |


** Functors take structures and produce other structure.

#+BEGIN_SRC sml

datatype CMP = LT | GT | EQ

signature ORD = sig
  type t
  val compare : t -> t -> CMP
end


structure IntOrd : ORD = struct
  type t = int
  fun compare x y = ...
end


functor Invert ( O : ORD ) = struct
   type t = O.t
   fun compare x y = O.compare y x
end

struct InvIntOrd = Invert (IntOrd)

functor Sort (O : ORD) = struct
   fun sort (xs : O.t list) = ....

end

#+END_SRC

#+RESULTS:
#+begin_example
datatype CMP = EQ | GT | LT
signature ORD =
  sig
    type t
    val compare : t -> t -> CMP
  end
functor Invert(O: sig
                    type t
                    val compare : t -> t -> CMP
                  end) :
              sig
                type t
                val compare : O.t -> O.t -> CMP
              end
#+end_example


** General facts

1. Structures/functors are unique to ML and its dialect. But they can
   be retrofitted to any language.

2. One can defunctorise the code, i.e. take a program with structurs
   and functors and rewrite it to get code that is without them.  In
   fact the first phase of MLton compiler is precisely this.

3. structure/functors are what are know as zero-cost
   abstraction. There is no cost at runtime (space or time) for using
   the feature structure/functors. Maybe compile time will increase.


* DONE Structures and funtors continued                           :CLASSROOM:


** Some interesting libraries

1. Look for utility functions in the Standard Basis library

#+BEGIN_SRC sml

open Array

val myintarray = array (10, 42)
val mystrarray = array (10, "The answer is")
val _ = update (myintarray, 0, 100)

#+END_SRC

#+RESULTS:
#+begin_example
opening Array
  type 'a array = 'a ?.array
  type 'a vector = 'a ?.vector
  val maxLen : int
  val array : int * 'a -> 'a array
  val fromList : 'a list -> 'a array
  val tabulate : int * (int -> 'a) -> 'a array
  val length : 'a array -> int
  val sub : 'a array * int -> 'a
  val update : 'a array * int * 'a -> unit
  val vector : 'a array -> 'a vector
  val copy : {di:int, dst:'a array, src:'a array} -> unit
  val copyVec : {di:int, dst:'a array, src:'a vector} -> unit
  val appi : (int * 'a -> unit) -> 'a array -> unit
  val app : ('a -> unit) -> 'a array -> unit
  val modifyi : (int * 'a -> 'a) -> 'a array -> unit
  val modify : ('a -> 'a) -> 'a array -> unit
  val foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val foldl : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val foldr : ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
  val findi : (int * 'a -> bool) -> 'a array -> (int * 'a) option
  val find : ('a -> bool) -> 'a array -> 'a option
  val exists : ('a -> bool) -> 'a array -> bool
  val all : ('a -> bool) -> 'a array -> bool
  val collate : ('a * 'a -> order) -> 'a array * 'a array -> order
  val toList : 'a array -> 'a list
  val fromVector : 'a vector -> 'a array
  val toVector : 'a array -> 'a vector
val myintarray = [|100,42,42,42,42,42,42,42,42,42|] : int array
val mystrarray =
  [|"The answer is","The answer is","The answer is","The answer is",
   "The answer is","The answer is","The answer is","The answer is",
   "The answer is","The answer is"|] : string array
#+end_example

2. Additional utility functions and libraries are available as part
   of the SML of NL library. This is also available in mlton

** Unique value creation

1. Not Globally unique but unique in a particular run of the computation.


#+BEGIN_SRC sml

datatype order = LESS | GREATER | EQUAL

signature UNIQUE = sig

   type uniq

   val new : unit -> uniq

end

(* opaque signature *)
structure Unique :> UNIQUE = struct
  type uniq = int

  val uniqRef = ref 0

  (* wrong implementation *)
  fun new () = 10 (* fixme *)



end

val x = Unique.new ()
(* val y = [x, 42] *)



(* Problem: Nothing gurantees that all the unique
   values that I created in the program is via Unique.new ()
 *)


#+END_SRC

#+RESULTS:
: datatype order = EQUAL | GREATER | LESS
: signature UNIQUE =
:   sig
:     type uniq
:     avl new : unit -> uniq
:   end
: structure Unique : UNIQUE
: val x = - : Unique.uniq


2. Atom implementation

A representation for variables in programs.

#+BEGIN_SRC sml

signature ATOM = sig

   type atom

   val atom  : string -> atom
   val toString : atom -> string

   val compare : atom * atom -> order

....
end

structure Atom :> ATOM = struct

   type atom = int

   val atomRef = ref 0

   (*
   1. A referencce to map from int (atom) -> string

   2. A reference to a map from string -> int (atom)

   *)

   type toStringMap = string IntRedBlackMap.map
   type atomMap     = atom StringRedBlackMap.map

   val toStringRef : ref toStringMap = ref IntRedBlackMap.empty
   val atomMap     : ref atomMap     = StringRedBlackMap.empty

   fun atom str = let val toStrMP = !toStringRef
                   (* loopkup the given str in toStrMP
                      1. It is already there in which case return the associated atom (int)
                      2. otherwise increment atomRef and assign str to this new value
                    *)

   fun toString atm = lookup
end

#+BEGIN_SRC sml

(* int -> int *)

val const ( _ : int) = 0
val incr x = x + 1


(* Given a function of type 'a -> 'a, 'a -> 'b -> 'a , int -> b -> int  *)

fun foo x = x

#+END_SRC

Benign side effect :: A side effectful computation that can be treated
like a pure computation The atom and toString functions of the Atom
structure look pure outside the structure although internally they
have side effect.


#+END_SRC
* DONE Lambda calculus and computability                          :CLASSROOM:

** Local declarations (non-recursive let).


#+BEGIN_SRC sml
fun foo x = let val y = x + 1
            in y * x
            end

#+END_SRC

#+RESULTS:
: val foo = fn : int -> int

#+BEGIN_EXAMPLE

let v = e1
in e2

===

(λ v . e2) e1

(fn v => e2) e1

....x = .. (let x = e1 in e2) ....

   The x in the expression e1 will be coming from
the outside scope

#+END_EXAMPLE

One can think of ~let v = e1 in e2~ as a syntactic sugar for
~(λ v . e2) e1~


Non-recursive let explanation
#+BEGIN_EXAMPLE

      <-----------
                 |
        (let x = x + 1 in .... x ...)
             ^                 |
             +-----------------+


  (let x = 5
     in
       let x = x + 1  (* this binds x to 5 + 1 = 6 *)
          in x        (* x here is 6 *)
       end
     end
  )

  This entire expression evaluates to 6
#+END_EXAMPLE

In OCAML there is ~let~ and ~let rec~

** Recursion and Fixpoints

1. Every lambda calculus expression is a function

2. A fixpoint of a function say F is a value X such that F X = X.

*** Fixpoint theorem

1. Every *closed* lambda calculus function has a fixed point.


2. This fixpoint is effectively computable. There is a λ-calculus
   combinator ~Y~ such that for all closed lambda calculus expressions
   ~F~, ~YF~ is the fixed point of ~F~.

- Closed expressions :: Expressions without free variables
- Combinator  :: Another name for closed expression.

- Consequence of part 1 :: In terms of recursive definition this means
     that any recursive definition of a function can be achieved
     through computing the appropriate fixpoint.

- Consequence of part 2 :: Think of a compiler that takes your
     favourite programming language and converts it into
     λ-calculus. The second part allows you to write such a compiler
     for recursive definitions.

     For a recursive equation like fact this means that you can write
     it as.

#+BEGIN_EXAMPLE
let F = fn f => fn n => if n <= 0 then 1 else n * f (n - 1)
   in let fact = Y F
          in  ....
          end
   end
#+END_EXAMPLE

Only closed expressions have meanings completely determined. In general,
the value associated with an expression depends on its free variable.

~λ x . x~ :: This is the identity function.

~x~ :: The value is determined only when the value of x is determined.


*** Fix points gives recursion.

1. letrec f x = ... f y .... in e

   F = λ f x . .....f y .....

#+BEGIN_SRC sml

fun fact n = if n <= 0 then 1
             else n * fact (n - 1)

val y = fact 4 (* this is just to check fact *)


fun F f n = if n <= 0 then 1 else n * f (n - 1) (* notice there is no recursion *)

val G = fn f => fn n => if n <= 0 then 1 else n * f (n - 1)

#+END_SRC

#+RESULTS:
: val fact = fn : int -> int
: val y = 24 : int
: val F = fn : (int -> int) -> int -> int
: val G = fn : (int -> int) -> int -> int
                  A               A

#+BEGIN_EXAMPLE

fact = λ n . if n <= 0 then 1 else n * fact (n - 1)

We want fact to be a solution of the above recursion


F = λ f . λ n . if n <= 0 then 1 else n * f (n - 1)

g is the fixpoint of F

This means g satisfies the recursion

   g = F g

g = (λ f . λ n . if n <= 0 then 1 else n * f (n - 1)) g
  = λ n . if n <= 0 then 1 else n * g (n - 1)

Solution of the recursion
 f = M (f)
 is the fixpoint of  λ f . M (f)

#+END_EXAMPLE

1. What is the fixpoint of ~F~ if it exists ?

   The fixpoint of ~F~ is that ~X~ such that ~F X = X~.

   ~F X is fn n => if n <= 0 then 1 else n * X (n - 1)~

   ~F X = X~ means ~X = F X~ which means

   ~X = fn n => if n <= 0 then 1 else n * X (n - 1)~
   ~fact = fn n => if n <= 0 then 1 else n * fact (n - 1)~

2. The recursive function definition ~fact~ is nothing but the fixpoint of
   The function ~F = fn f => fn n => if n <= 0 then 1 else n * f (n - 1)~


3. Notice that ~F~ is not recursive but its fixpoint is the solution to
   the recursive equation for ~fact~.

*** Proof of fixpoint theorem

1. We want the fixpoint of F

    θ = fn x => F (x x)

    θ θ = (fn x => F ( x x)) θ

        ⇒(β-reduces) F (x x) [ x := θ ]

        = F (θ θ)

        This proves that θθ is the fixpoint of F because θθ = F (θθ)

    Note that F (x x) is different from ((F x) x)
2. The Y-combinator for computing fixpoint.

   Given F the fixpoint of F is (λ x . F ( x x ))(λ x . F (x x))

   Y is that function that maps F to (λ x . F ( x x ))(λ x . F (x x))

   Y = λ f .  (λ x . f (x x)) (λ x . f (x x))

   Y is the desired fixpoint combinator.

   Y F = (λ f .  (λ x . f (x x)) (λ x . f (x x))) F
       = (λ x . F (x x))(λ x . F (x x))
       which is the fix point of F by part 1.

*** Some fun fixpoint combinators.

#+BEGIN_SRC

θ = λ p . λ k . k (p p k)

P = θ θ

P F = θ θ F  =  (λ p . λ k . k (p p k)) θ F
             => (λ k . k (θ θ k)) F
             => F ( θ θ F)

θθ is a fixpoint combinator like Y.

θ =   λ n λ e λ r λ a λ  j .  j(neeraj)

P = θ θ θ θ θ

Claim is P is a fixpoint combinator.

P F = (λ n λ e λ r λ a λ  j .  j(neeraj)) θ θ θ θ F
    = (λ j . j (θ θ θ θ θ j)) F)

    = F (θ θ θ θ θ F)
    = F (P F)



#+END_SRC

* DONE Typed Lambda calculus                                      :CLASSROOM:
<2020-10-05 Mon>

** So far.

So far we have seen untyped lambda calculus. It is a Turing complete
programming language, i.e. any computation task can be solved using
lambda calculus. We can have a semi-decision algorithm for any
recursively enumerable language of {0,1}*.

Lambda calculus is a full-fledged programming language.

1. There are no bultin constants or types like integers.

Adding types to lambda calculus. Constants and functions (builtin).


** λ-calculii and types.

The thing of interest for us is judgements ~e : τ~ where ~e~ is a term
and ~τ~ is a type.


*** The world of types

1. Start with some basic types, for eg. ~nat~, ~bool~, ....

2. The function type ~τ₁ -> τ₂~

#+BEGIN_EXAMPLE

<type> := one of the basic types like nat bool etc
       | <type>₁ -> <type>₂          (* function type or arrow type *)


#+END_EXAMPLE

*** The world of terms.

(λ x : τ . e)

These judgements e : τ, what do they mean ?  2 : nat means that we
cannot "apply" 2 to anything.

Suppose you know that e : nat then

1. You can use e in any context that expects a nat.  e.g (e + 1) is
   allowed

2. You cannot use e where a nat is not allowed e.g. (e x) is not
   allowed.


The fact that e : nat rules out the use of e in certain context in a
λ-calculus term. Or in other words, consider any context where e occurs
in a λ-calculus term M, we can decide whether e is used like a nat or not.


*** Types as a specification to values.

The judgement e : nat should be seen as a /specification/ of the
"program" e.

1. A specification or spec is a property that the program satisfies.
   For example, for scheduling /fairness/, i.e  any process that is
   ready should be scheduled to run in a finite amount of time.

2. A spec for a sorting program is that it "sorts the list".

   - Non-contracting :: If x is the input to the sort program then
        length of x = length of (sort x).


*** There are two problems associated with types.

- Type checking :: Given a term ~e~ and a type ~τ~, can we derive the
                   judgement ~e : τ~.

- Type inference :: Given a term ~e~ compute a type ~τ~ such that ~e :
                    τ~ is derivable.


We have to give the type rules for the calculus that we are talking
about.




** Simply typed lambda calculus.


1. Types: Basic types + arrow types.

   τ := nat
     |  τ₁ -> τ₂


When we want to derive the judgement ~e : τ~, we need a typing
context, i.e.  We need as assumption a set of judgements ~Γ = { x :
τ₁, x₂ , τ₂ .... }~ for all free variables of ~e~.


Say I want to arrive at this conclusion.
~x : nat~

I cannot /assert/ ~x : nat~ unless I /know/ that ~x : nat~.

The judgement ~x : nat~ is only valid under the assumption ~x : nat~.

x : nat ⊢ x : nat


~Γ ⊢ e : τ ~  is to be read as the judgement ~e : τ~ is valid in the context ~Γ~

A typing context Γ is just a list of type assumptions on variables.

Γ = { x₁ : τ₁, ... xₙ : τₙ }.


** Rules of typing.

*** Syntax consists of

- Variables :: x, y , z ..
- Function application :: e₁ e₂ ,i.e. The function  e₁ applied on e₂
- function abstraction :: (λ x:τ . e)

*** Typing rules

**** Types

#+BEGIN_EXAMPLE

τ := nat
  | τ₁ -> τ₂ |

#+END_EXAMPLE


There should be a rule for all the three term construction rules.

- A General Rule looks like ::

  #+BEGIN_EXAMPLE

   Pre-cond1
   Pre-cond2
   ...
   Pre-condn

   =========================

   conclusion.


#+END_EXAMPLE

- VAR :: The variable rule.

  #+BEGIN_EXAMPLE


   ===================
    {x : τ} ⊢ x : τ

  #+END_EXAMPLE

  Under no pre-condition, we can derive the judgement x : τ under the context x : τ

- APP ::

  #+BEGIN_EXAMPLE

    Γ ⊢ e₁ : τ₁ -> τ₂
    Γ ⊢ e₂ : τ₁

    =======================

    Γ ⊢ e₁ e₂ : τ₂


  #+END_EXAMPLE

  - Pre-condition ::
     ~e₁ : τ₁ -> τ₂~ under the context ~Γ~ and
     ~e₂ : τ₁~ under the cotnext ~Γ~

  - Conclusion ::
    ~e₁ e₂ : τ₂~ under the context ~Γ~.
- ABS ::

  #+BEGIN_EXAMPLE

   Γ ∪ { x : τ₁ } ⊢  e : τ₂

   ==============================

   Γ ⊢ (λ x : τ₁ . e) : τ₁ -> τ₂

  #+END_EXAMPLE

  - Pre-condition :: With the assumption ~x : τ₁~ suppose I derive ~e : τ₂~ then
  - Conclusion  :: (λ x : τ₁ . e) : τ₁ -> τ₂
* DONE Typed Lambda calculus Contd                                :CLASSROOM:

** Typing rule review

We want to have a complete set of rules for forming the judgement ~e : τ~ for each
λ-calculus term ~e~

~Γ~ is a set of type assumptions (i.e. judgements of the kind ~x : τ~). Conclusions are always
of the form ~Γ ⊢ e : τ~ (I can derive the judgement ~e : τ~ from the set of type assumptions ~Γ~.

Every Rule looks like
#+BEGIN_EXAMPLE
Pre-conditions
===============
Conclusion

#+END_EXAMPLE


- VAR :: The variable rule for the judgement ~x : τ~.

  #+BEGIN_EXAMPLE


   ===================
    Γ ∪ {x : τ} ⊢ x : τ

  #+END_EXAMPLE
- APP :: The application rule for judgement ~e₁ e₂ : τ~

  #+BEGIN_EXAMPLE

    Γ ⊢ e₁ : τ₁ -> τ₂
    Γ ⊢ e₂ : τ₁

    =======================

    Γ ⊢ e₁ e₂ : τ₂


  #+END_EXAMPLE
- ABS :: The abstraction rule for judgement ~fun (x : τ₁) => e  : τ₁ -> τ₂

  #+BEGIN_EXAMPLE

   (Γ ∪ { x : τ₁ }) ⊢  e : τ₂

   ==============================

   Γ ⊢ (λ x : τ₁ . e) : τ₁ -> τ₂
  #+END_EXAMPLE

- Weakening ::

#+BEGIN_EXAMPLE

   Γ ⊢ e : τ
   ==========
   Γ ∪ {x : τ₁} ⊢ e : τ


#+END_EXAMPLE



~Γ ⊢ e : τ~, I can derive the type judgement ~e: τ~
given the assumption set ~Γ~

We are now talking about the ABS rule.

- Judgement that I want to derive ::
     ~(fun (x : τ₁) => e)  : τ₁ -> τ₂~

When can the above function i.e. (fun (x : τ₁) => e)
have the type ~τ₁ -> τ₂~ ?
- Answer :: only when I have the pre-conditon that
            e : τ₂ under the assumption x : τ₁

** Some proofs of judgements.

A proof of a judgement should be a list of judgements of the kind Γ ⊢ e : τ₁. where

J₁ (R₁) ,J₂ (R₂),...,Jₙ (Rₙ)

(1) Rᵢ's are one of the instatiations of the the rule VAR, ABS, APP.

(2) every judgement Jᵢ follows from a set of judgements { Jₗ : l < i}  using one of the VAR,ABS or
    APP rule.


Jₙ is the judgement  (fun x : int => fun y : bool => x) : int -> bool -> int


1. ~x : int            ⊢ x : int~
                                   (VAR)
2. ~x : int, y : bool  ⊢ x : int~
                                  (VAR | WEAKENING (1) )

3. ~x : int            ⊢ (fun y : bool => x)  : bool -> int~
                                  (ABS (2))

4. ~⊢ fun (x : int) => fun (y : bool) => x) : int -> bool -> int~
                                  (ABS (3))
Γ ∪ x : τ₁ ⊢ e : τ₂
====================
Γ | (fun x : τ₁ => e) : τ₁ -> τ₂

#+END_EXAMPLE

In the case of 3 what is Γ ?
- Answer :: { x : int }
What is e is ?
- Answer :: (fun y : bool => x)

What is τ₁ ?
- Answer :: bool

What is τ₂ ?
- Answer :: int

What is x ?
- Answer :: y


** Exercise

Prove the judgement ~⊢ (fn x : nat => fn y : bool => x) 3 true : nat~

You can also use the additional Rules

#+BEGIN_EXAMPLE

===========           (TRUE-rule)
 true : bool

===========          (FALSE-rule)
 false : bool

===========  (NAT-n rule for each natural number n)
  n : nat

#+END_EXAMPLE

#+BEGIN_EXAMPLE
λ x y . x y  is same as λ x . λ y . x y

fn x y => x y   is same as fn x => (fn y => x y)

#+END_EXAMPLE
* DONE Polymorphism and Hindley-Milner types                      :CLASSROOM:

** Types

*** Monotypes

Mono-types or monomorphic types.

#+BEGIN_EXAMPLE
τ = nat
  | α        type variable
  | τ₁ -> τ₂
#+END_EXAMPLE

- Explanations ::
  These types are called mono-morphic types.

  "fixed but arbitrary"

   Should distinguish the mono-type ~α~ from the
   poly type ~∀ α . α~.


#+BEGIN_EXAMPLE

nat -> ∀ α. α -> ∀ β. β -> nat

#+END_EXAMPLE


*** Poly types.

- Type schemes ::
    #+BEGIN_EXAMPLE

  σ = τ  (where τ is a mono type)
    | ∀ α . σ₁  where (α is some type variable and σ₁ is some type scheme.
  #+END_EXAMPLE

  In general a type scheme ~σ = ∀α₁∀α₂ ...∀αₙ τ~.  In our type
                  checking/inference algorithms we only allow for
                  these types.

  - Note : If σ₁ and σ₂ are type schemes, then it is not always
    the case that ~σ₁ → σ₂~ is a type scheme.
    If σ₁ = ∀α. α → α and σ₂ = ∀ β. β  ~σ₁ → σ₂~ is  (∀α. α → α) →  (∀ β. β)
    Which is clearly not a type scheme.

- Background ::

-  We cannot have arbitrary polytypes as that would make the type
  checking problem undecidable.  For Hindley-Milner
  types we assume all the type variables are quantified
  in the /outer most layer/.

| Example types                    | Hindley-Milner or not |
|----------------------------------+-----------------------|
| nat                              | yes                   |
|----------------------------------+-----------------------|
| α -> β                           | yes                   |
|----------------------------------+-----------------------|
| σ₁ = ∀ α . (α -> β)              | yes                   |
|----------------------------------+-----------------------|
| σ₂ = ∀ α . (α -> (∀ β . α -> β)) | no                    |


- Without the Hindley-Milner restriction, type checking itself becomes undecidable.
  System-F is the lambda calculus where the ∀ quatification is allowed at any layer.
  For System-F type checking is undecidable. That is the reason we restrict to only
  that fragment of System-F where all the quatification is in the outer most layer.

#+BEGIN_SRC sml

val map : ('a -> 'b) -> 'a list -> 'b list

#+END_SRC

~map : ∀ α ∀ β . (α → β) → α list → β list~

** Type inference rules

We have the same rules as that of simply types lambda calculus (i.e. VAR, APP and ABS) for
all monotypes.

*** Some additional rules.

- Specialisation ::

  Γ ⊢ e : σ
  σ₁ ≤ σ
  ========================
  Γ ⊢ e : σ₁




~map : ∀ α ∀ β . (α → β) → α list → β list~

Let τ₁ and τ₂ be any monotype then clearly I can have the judgement
map : (τ₁ → τ₂) → τ₁ list → τ₂ list

map : ∀ γ₁ ∀ γ₂ ∀ γ₃ . (γ₁ -> (γ₃ * γ₂)) -> γ₁ list -> (γ₃ * γ₂) list

By substituting α with γ₁  and β with γ₃ * γ₂

map : (γ₁ -> (γ₃ * γ₂)) -> γ₁ list -> (γ₃ * γ₂) list


.
.
.
⊢ map : ∀ α ∀ β . (α → β) → α list → β list~


.
.
.
⊢ map : (γ₁ -> (γ₃ * γ₂)) -> γ₁ list -> (γ₃ * γ₂) list
⊢ map : ∀ γ₁ ∀ γ₂ ∀ γ₃ . (γ₁ -> (γ₃ * γ₂)) -> γ₁ list -> (γ₃ * γ₂) list


Let σ = ∀ α₁ ... ∀ αₙ . τ

1. τ [α₁ := τ₁]...[αₙ := τₙ] = τ' ≤ σ

2. ∀ β₁ ... ∀ βₘ . τ [α₁ := τ₁]...[αₙ := τₙ] = σ' ≤ σ

    Provided βᵢ's are not free variables of σ


~map : ∀ α ∀ β . (α → β) → α list → β list~

(map (fn x => [x]))

In the above context map should have type

∀ α . (α -> α list ) -> α list -> α list list


- Generalisation ::

Γ ⊢ e : σ
=============== (α ∉ FTV(Γ))
Γ ⊢ e : ∀ α . σ


Γ = { x₁ : σ₁, ..... , xₙ : σₙ }

FTV(Γ) = FV(σ₁) ∪ ... ∪ FV(σₙ)

If α ∉ FTV(Γ) then the judgement Γ ⊢ e : σ  can be proved for all α because it
is not part of the assumption Γ.

- This is a wrong proof as it violates the side condition
  α ∉ FTV(Γ)

1. {x : α} ⊢ x : α
2. {x : α} ⊢ x : ∀ α . α  (violation of side condition)
3. {x : α} ⊢ x : ∀ β . β


- THis proof is correct

1. {x : α} ⊢ x : α     (VAR rule)

2. ⊢ λ x . x : α → α   (ABS rule with 1)

         (No matter what is α we have a proof of the Judgement λ x . x : α → α)

3. ⊢ λ x . x : ∀ α . α → α (GEN on 2)


* DONE Type inference algorithm.                                  :CLASSROOM:


B = {nat , bool}

** Mono-types

#+BEGIN_EXAMPLE
τ = t            t ∈ B
  | τ₁ → τ₂      τ₁, τ₂ are monotypes
  | α            α is a type variable
#+END_EXAMPLE

** Type schemes

σ = ∀ α₁....∀αₙ . τ

#+BEGIN_EXAMPLE
σ = τ
  | ∀ α . σ'
#+END_EXAMPLE


** Typing rules


1. For monotypes it is the same as that of simply typed lambda calculus.

*** Bultins

#+BEGIN_EXAMPLE

================ for all n ∈ ℕ
 ⊢ n : nat

#+END_EXAMPLE


*** Var

=============
x : τ ⊢ x : τ


*** App

#+BEGIN_EXAMPLE


Γ ⊢ e₁ : τ₁ -> τ₂
Γ ⊢ e₂ : τ₁

===================

Γ ⊢ e₁ e₂ : τ₂


#+END_EXAMPLE


*** Abs

#+BEGIN_EXAMPLE

Γ , x : τ₁ ⊢ e : τ₂
====================
Γ         ⊢  λ x . e : τ₁ -> τ₂

#+END_EXAMPLE


** For type schemes

*** Specialisation

Γ ⊢ e : σ
σ'  ≤ σ
==========
Γ ⊢ e : σ'

*** Generalisation

Γ ⊢ e : σ
α ∉ FV (Γ)
================
Γ ⊢ e : ∀ α . σ


Notice that σ  ≤  ∀ α . σ


** Type inference problem

Given a set of typing assumption Γ and an expression e in the calculus
 find a type scheme σ such that Γ ⊢ e : σ.

1. We want σ to be the most general possible type. Suppose σ' is
   another type scheme such that Γ ⊢ e : σ' then we should have σ' ≤ σ

2. If e is ill-typed under Γ, i.e there is no type σ such that Γ ⊢ e :
   σ then the algorithm should flag a typing error

#+BEGIN_EXAMPLE

e = n     n ∈ ℕ
  | true
  | false
  | plus
  | and
  | x    x is a variable
  | e₁ e₂
  | λ x . e

#+END_EXAMPLE

** Algorithm W

- Main idea :: e is recursively defined so do a recursion on the
               structure of e.

- Second idea :: The algorithm will compute a monotype τ such that
                 the closure σ of τ under Γ is the most general possible type scheme such
                 that Γ ⊢ e : σ

- Third idea :: The algorithm should also keep track of all substitutions that it performed
                during the APP recursion step.

** Algorithm W

- Input  :: Γ a type assumption, A substitution Sᵢₙ and an expression e
- Output :: a monotype τ and a substitution Sₒᵤₜ such that Sᵢₙ (Γ) ⊢ e : τ'
  such that Closure (τ', Sᵢₙ(Γ)) is the most general such type and
  τ' = Sₒᵤₜ(τ)



Closure(τ, Γ) = ∀ α₁....∀ αₙ . τ  where {α₁,....,αₙ} = FV(τ) ∖ FV(Γ)

Γ = x : α

e = λ y . x  : β -> α = τ

THen Closure(τ,Γ) = ∀ β . β -> α


#+BEGIN_EXAMPLE
.
.
.
Γ ⊢ e : τ
Γ ⊢ e : ∀ α₁ ....∀ αₙ . τ  (GEN n-times)



#+END_EXAMPLE



*** For builtins

 e = n for some n ∈ ℕ

 Then we know that the most general type scheme
 σ such that Γ ⊢ e : σ is just ~nat~.

*** Variable

Let us say e is some variable x

Let σ be the type assigned to x in the type assumption Γ

Γ = Γ' ∪ {x : σ}


Let σ = ∀ α₁,...∀ αₙ . τ

Compute fresh type variables β₁,...,βₙ.  return the type e : τ' = τ
[α₁ := β₁] .... [αₙ := βₙ] i.e replace all type variables αᵢ with the
corresponding fresh variable βᵢ

e is x
the returned type is Sᵢₙ(τ')

Closure of τ' is  ∀ β₁...̱∀ βₙ . τ'  = σ







WHat ever output we give say τ, we need the fact that

Γ ⊢ e : τ

*** App case

e = e₁ e₂

1. Recursively compute the type τᵢ associated with eᵢ under the type assumption Γ
   If any of this fails then failure. Otherwise

   W(Γ, Sᵢₙ, e₁) = (S₁, τ₁) and
   W(Γ, S₁, e₂)  = (S₂, τ₂)

   However I should have the property that  e₁ : α -> β and e₂ : α

   Get hold of fresh type variables α and β.

   Unify (α -> β ≡ τ₁ , α ≡ τ₂)  Will get a substitution S.

   Return (S, S(β))



*** Abs case

e = λ x . e' . If at all e is well typed then it should be something like
e : τ₁ → τ₂


Γ' = Γ ∪ {x : α} for some fresh type variable α.

W(Γ', e', Sᵢₙ) = (Sₒᵤₜ, τ)

Return of W(Γ, e, Sᵢₙ) = ( Sₒᵤₜ, τ' -> τ)  where τ' is Sₒᵤₜ (α)

#+BEGIN_EXAMPLE

e = λ x . plus x 1

#+END_EXAMPLE

Γ = ∅

{x : α}  Compute type of plus x 1 Abs setp

{x : α} : Compute type of (plus x)  Compute the type of (1)  App

{x : α} : Compute type of plus, Compute type of x (App rule)


plus : nat -> nat -> nat

x : alpha

Unify (β -> γ) ≡ nat -> (nat -> nat), β ≡ α

α ≡ nat



#+BEGIN_EXAMPLE

Γ , x : τ₁ ⊢ e : τ₂
====================
Γ         ⊢  λ x . e : τ₁ -> τ₂

#+END_EXAMPLE







#+BEGIN_EXAMPLE


Γ ⊢ e₁ : τ₁ -> τ₂
Γ ⊢ e₂ : τ₁

===================

Γ ⊢ e₁ e₂ : τ₂


#+END_EXAMPLE


#+BEGIN_SRC sml
val e = map (fn x => x + 1) : int list -> int list
#+END_SRC

map : ('a -> 'b) -> 'a list -> 'b list

'a = int
 'b = int

* TODO Verification, Logic, Constructive Mathmatics

1. Programming

2. Correct programs. Want to ensure that programs are "correct"

3. Specification. We say what the program needs to do rather than telling how to do.

4. Correctness of programs means that programs satisfy the specification that it give for this.

We want to sort a list of numbers. bubble sort, quick sort, merge sort (how to sort question)

Give me a specification for a sorting algorithm.

1. The sorted list should be of the same length as the input.

2. ∀ x ∈ l, x ∈ sort l

3. The output of the algorithm should be monotonically increasing.

The identity function on list is satisfies the above spec but is not clearly a sorting algorithm.
Reverse function.


Formal specification

1. There should be a language to express the properties
2. The proofs should be machine checked.


The type system is a formal system.

Consider a language that does not enforce correctness of types at compile time.
A lot of bugs escapes to the runtime where it is much more costly.

1. Write test cases to catch bugs. TDD test-driven development.


You want a mechanism for proving program correct.

If you have a strong type system then clearly bugs like "hello" + 42 will be caught.


You can think of the typing rules as proofs in a logic which is automatically checked.

** Typing rules.

*** Builtins

#+BEGIN_EXAMPLE

===============  for all n ∈ ℕ
⊢ n : nat

#+END_EXAMPLE


#+BEGIN_EXAMPLE

===============
⊢ true : bool

#+END_EXAMPLE

... (the rest is exercise)

#+BEGIN_EXAMPLE

===========================
⊢ plus : nat -> nat -> nat


#+END_EXAMPLE

#+BEGIN_EXAMPLE

====================
⊢ and : bool -> bool -> bool

#+END_EXAMPLE

*** Variables

To determine the type of x, a variable, we need to assume its type.

#+BEGIN_EXAMPLE

===================
 {x : τ}  ⊢ x : τ


====================   A rule in logic
  A ⊢ A

#+END_EXAMPLE

*** Application

#+BEGIN_EXAMPLE

Γ ⊢ e₁ : τ₁ → τ₂
Γ ⊢ e₂ : τ₁
====================
Γ ⊢ e₁ e₂ : τ₂


Γ ⊢ A → B
Γ ⊢ A
===================
Γ ⊢ B


(modus-ponens)
#+END_EXAMPLE

1. Make sure that ~e₁ : τ₁ -> τ₂~

2. Make sure that ~e₂ : τ₁~

*** Abstraction

#+BEGIN_EXAMPLE

Γ ∪ { x : τ₁ } ⊢ e : τ₂
========================================
Γ              ⊢ (λ x : τ₁ . e)  : τ₁ → τ₂

#+END_EXAMPLE


Γ ∪ {A } ⊢ B
================
Γ ⊢ A → B



Suppose I want to prove assuming Γ that  A => B. It is sufficient to prove B assuming A (and Γ)


λ x : τ₁ . e  is that function that takes x : τ₁ and gives out e : τ₂



A ∨ B


#+BEGIN_EXAMPLE

Γ ⊢ A
========

Γ ⊢ A ∨ B


Γ ⊢ B
========

Γ ⊢ A ∨ B


Γ ⊢ A -> C
Γ ⊢ B ->  C
=================
Γ ⊢  A ∨ B ->  C


#+END_EXAMPLE


#+BEGIN_SRC sml

(* or of logic *)
datatype ('a, 'b) Sum = left of 'a
                      | right of 'b


fun either f g (left a) = f a
  | either f g (right b)= g b

(* like the and of logic *)
type ('a,'b) prod = 'a * 'b


#+END_SRC

#+RESULTS:
: datatype ('a,'b) Sum = left of 'a | right of 'b
: val either = fn : ('a -> 'b) -> ('c -> 'b) -> ('a,'c) Sum -> 'b


#+BEGIN_EXAMPLE

Γ ⊢ e : 'a
===========================
Γ ⊢ left e : ('a , 'b) Sum


Γ ⊢ f : 'a -> 'c
Γ ⊢ g : 'b -> 'c
==================
Γ ⊢ either f g : ('a,'b) Sum -> 'c

#+END_EXAMPLE


** Curry-Howard Correspondence


Think of types as Logical Statements and terms as purported proofs of
statements. Type checking rules have a correspondence with that of
proof checking.


Suppose I have a language which very rich type system, Then The type
checking algorithm can double up as a proof checking algorithm.

In such languages.

1. You capture a statement as a type T in the language

2. You prove the statement T by giving an element x : T.


Such a language can be used as

1. A programming language

2. As a proof assistant : means a program that checks whether the given proof
   is correct

3. Think of it as both.

You can write programs and prove programs correct in the same language.

Coq, Isabelle, HOL etc






*** Structural rules.
**** Weakening

#+BEGIN_EXAMPLE

Γ               ⊢ e : τ
====================
Γ ∪ { x : τ₁ }  ⊢ e : τ
#+END_EXAMPLE

**** Contraction

#+BEGIN_EXAMPLE

Γ ∪ { x : τ₁ } ∪  { x : τ₁ }  ⊢ e : τ
===================================
Γ ∪ { x : τ₁ }  ⊢ e : τ

#+END_EXAMPLE


* TODO Rust: An approach to safe, low-level programming

** Main ideas.

- C/C++ like low level language.

C is like portable assembly. The advantages of this is that you can
code pretty "close to the metal" the call it. The programming model
and the processor model is not very different.

C/C++ is extreamly unsafe. Addresses and integers can be confused. No
array bound checking. Dangling pointers. Use without allocation etc.

Some of these bugs do not manifest even at runtime.

If there is a segmentation fault (which essentially is due to
accessing locations that are invalid) there is no way to even
reproduce these bugs often.

In SML for example computation happens as a set of reductions/rewritings.

- But safety like High level language.

  Catch the above bugs.


Rust "borrows" many interesting ideas from languages like SML (by
default things are immutable) It also codifies some best practices
from C++ programming (RIAA) making violation of this compile time
bugs.

- Targets low level programming.

  Things like operating systems, device drivers, programming language
  runtimes etc.


Idea for language/library designers

If possible push potential bugs from runtime to compile time.

** Hello world program

#+BEGIN_SRC rust
// C++ like line comments
/*

/* Nested C like comments.

*/

*/
fn main ()
{
  println!("hello world");  // semi-colon is a separator not a terminator
  println!("goodbye world")
}
#+END_SRC

** Mutability and type inference

#+BEGIN_SRC rust

fn main ()
{

let x = 10; // x is immutable
x = 5 // is an error because x is immutable

// Infinite loop

}
#+END_SRC

1. Rust is careful about mutabililty and like SML things are immutable
2. Rust can infer types.

** Things that need resource

Values in your language can be simple straight forward values like int
bool etc but they might also be ID's for resources.

For example an operating system lock is a resource.

1. Values can be "names" to resources. Like for example a socket in
   an OS can be represented by a integer but a socket really is much
   more than an integers.

2. Such values might need exclusive access

3. Values might point to memory resources. Pointers ultimately are integers but
   it is not the integral value of the pointer that is of interest to us.

   1. What is being pointed
   2. How much memory is available at this point etc

Rust gives you a way to manage values that have such resources tied to it.
It makes sure that "exclusivity" is maintained

Ownership model of Rust.

** Resource that I will discuss is Boxed values.

There are two kinds of values

-  Unboxed :: The value is the entire description of the object, examples are like boolean,
   integer constant (within the word size of the machine).

   Copying of unboxed value is easy

-  Boxed :: The value is not the entire story. E.g pointers or multi-precision Integers (i.e
       which cannot fit in the machine word)

   Copying has to distinguish between shallow copy vs
   deep copy.

   - Shallow copying of the list type in C is just copying the list pointer

   - A deep copying of a list is

#+BEGIN_SRC C

typedef struct Node
           { int data;
             struct Node *next;
           } Node;

typedef Node *List

List x y z ptr qtr;

x = SomeFunctionToCreateList()

y = x ; // This is a shallow copy as you are only copying the pointer

// Shallow copy leeds to dangling pointers.

// This is a deep copying
for(ptr = x; ptr != NULL; ptr = ptr -> next)
{
  qtr = malloc(...)
  qtr -> datum = ptr -> datum;
....
 }

// You might forget to free. Memory leaks


}

#+END_SRC


In C++ one would want to overload the assignment operators.

1. Should assignment operator do deep copy or shallow copy.

In C++ since memory is managed manually the decision can have consequences.

x = y ; in C++ might either be doing a shallow copy or a deep copy

If it is a shallow copy, I should not free y if it is no more used
If it is a deep copy, it makes sense to free y if it is no more used

f(x)

** Rusts ownership model


There are two types of values. One that follows
the Copy semantics and other that follows the move semantics

An assignment of the kind ~x = y~ is treated differently
depending on whether the type of x (and y) follows
Copy semantics or move semantics.

- Copy semantics :: x = y should seen as make a
copy of the value in y and store it in x

- Move semantics :: x = y should be seen as transfer
the value (and its ownership) to x

Example

~u32~ is an example of a type (unsigned 32-bit integer)
that follows the Copy semantics

~Box<u32>~ is an example of a type that follows Move
semantics.


#+BEGIN_SRC rust

fn main ()
{
   let x : Box<u32> = Box::new(10);
   let v = 10

   bar(v);

   foo(x)


/ foo(x); // let y = x

// let u = x;
// blah(u)

// let z = x

   ...
   ...

}

// This is in a library

fn foo (u : Box<u32>)
{
  blah(u)
}
#+END_SRC





** Freeing of resources in rust

In rust an object/resource is freed when it has no owner or
equivalently as soon as the owner dies (when the last owner goes out
of scope). (No manual freeing is required)


This is correct because Rust ensures at compile time that
there is only one owner for any value that satisfies the
Move semantics.


** Ownership and Borrowing.

The two rules of Ownership and Borrow.

1. There is at any point of time only one owner for any value
2. There is atmost one mutable borrow of a resource


- Owner ship transfers from x to y when we perform ~y = x~ ;
- When the last owner of the value dies then resource is freed.


Assignment to a reference variable should be seen as the reference
variable borrowing the value/resource

#+BEGIN_EXAMPLE rust

let xbox = Box:new(10);
let ybox = xbox; // ownership is with ybox.
let ubox = Box::new(42);

let zbox = &ybox;  // this is only a borrow the type of zbox is &Box<u32>

let z = 5;
let mut u = 5;

/*
let <var> = ...
let mut <var> = ...

*/
// z = 10;  // is an error because z is immutable
          // so z cannot be changed.

u = 10 ; // This is okey because u is mutable

//  zbox = &ubox // This is an error as zbox
                 // is an immutable variable.
                 //


/*
  (zbox is a immutable variable) that has the immutable reference to ybox
*/


let (mut vbox) = &ybox; //

/*

(vbox is a mutable variable) of ...

So vbox can be reassigned

*/
vbox = &ubox ; // This is allowed
              // The borrow from ybox is
              // no more there but now vbox
              // has a borrow from ubox
// foo(&ubox) ;; fn foo(u : &Box<u32>)
// u = &ubox ... body of the function
// let vbox : &mut Box<u32> = &...

// The reference allows you to update the
// contents



#+END_EXAMPLE




#+BEGIN_SRC rust

let x = value

/*
&x is immutable ref to x and &mut x is error

*/

let mut y = value
let mut y' = ....
/*
  &y is an immutable reference to y and &mut y is a mutable reference to y

Through &y you cannot change y but through &mut y you can change y.

*/

let xr = &mut y

*xr = value'  // This is allowed

xr = &mut y' // This is not allowd as xr is changed

/* What happens here ? */

#+END_SRC

<

1. If ~let x = value means &x has to be immutable
      let mut x = value means &x is an immutable reference and &mut x is the mutable reference to x


1. A ~&mut x~ (mutable reference of x) of a immutable variable x is error
2. A ~*x = value~ is error unless x is of type ~&mut T~

Rules of borrowing

1. You can have any number of immutable reference

2. You can have atmost one mutable reference. If there is a mutable reference then
   no other borrowing is allowed (whether mutable or not). There can be only one
   "route" to update the contents of a variable

#+BEGIN_SRC rust

let mut x = value
{

  let y = &mut x
  let z = &x // is not allowd because the borrow y is a mutable borrow and thus
                disallows any other borrow (mutable or not)

} // y's life time is over so now you can have as many borrow as you want
let z = &x  // is not allowed
let z1 = &x//

#+END_SRC

The reason is

With a immutable reference you can only "read" the contents not modify. It is okey to
have any number of them
